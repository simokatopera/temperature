<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilaseuranta</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "//unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <script src="chartfunctions.js" defer></script>

    <style>

        .graphelement {
            width: 1100px;
            height: 380px;
        }
        .datatable,
        .datatable th,
        .datatable td {
            border: 1px solid;
            text-align: center;
        }
        .latestreadingtable,
        .latestreadingtable th,
        .latestreadingtable td  {
            border: 1px solid;
            text-align: center;
        }
        .active {
            background-color: lightgreen;
        }
        .morninghigh {
            background-color: rgb(245, 113, 113);
        }
        .morninglow {
            background-color: rgb(174, 139, 255);
        }
        .eveninghigh {
            background-color: rgb(245, 113, 113);
        }
        .eveninglow {
            background-color: rgb(174, 139, 255);
        }
        .estimatedvalue {
            background-color: gray;
        }
        .diffvalue {
            background-color: yellow;
        }
        .actionbutton {
            background-color: lightblue;
        }
        .yearbutton {
            background-color: lightgray;
            border-radius: 4px;
            margin: 2px;
        }
        .yearbutton:hover {
            background-color: gray;
        }
        .yearbuttonselected {
            background-color: red;
            color: white;
        }
        .yearbuttonselected:hover {
            background-color: rgb(246, 130, 130);
            color: white;
        }
        .actionbutton.active {
            background-color: red;
            color: white;
        }
        .setmargin5 {
            margin: 5px;
        }
        #loader2 {
            position: absolute;
            left: 200px;
            z-index: 1;
        }
        #daygraph {
            display: inline-block;
            width: 400px;
            height: 380px;
        }
        .scrollbox {
            height: 400px;
            width: 520px;
            overflow: scroll;
        }
        #Error {
            color: red;
            font-size: 24px;
        }
        .hidden {
            display: none;
        }
        .graphtitle {
            font-size: 20px;
            font-weight: bold;
        }
        .backbutton {
            margin-bottom: 10px;
            border-radius: 10px;
            color: #fff;
            border-color: #0d6efd;;
            background-color: #0d6efd
        }
        .loader {
            border: 5px solid #f3f3f3;
            /* Light grey */
            border-top: 5px solid #3498db;
            /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
        }        
        @media screen and (max-width: 1080px) {
            .scrollbox {
                height: 420px;
                width: 420px;
                overflow: scroll;
            }            
        } 
        @media screen and (max-width: 800px) {
            .hideifnarrow {display:none}
            .scrollbox {
                height: 400px;
                width: 280px;
                overflow: scroll;
            }        
        }        
    
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilaseuranta</h1>
        </div>
        <div id="app" class="page-content">
            <div class="hiddenstart hidden">
                <button class="backbutton" onclick="history.back()">&laquo;Takaisin</button>
                <div id="hiddenbutton"></div>
            </div>

            <div id="loader1" class="loader hidden"></div>            
            <hr>
            <div id="Error"></div>
            <div class="row">
                <div class="col-6" :style="loading?'display:none;':'display:inline-block;'">
                    <readings :temperatures="listedtemperaturereadings" :selectedday="selectedday" :allreadings="alltemperaturereadings" @dayselected="dayselected" @savefile="savefile"></readings>
                    <div id="loader2" class="loader hidden"></div>
                    <div class="hiddenstart hidden">
                        <button  class="yearbutton" v-for="item in listedtemperaturereadings.years" :class="{yearbuttonselected: this.selectedyearbutton == item.year }" @click="showselectedyear(item)">{{ item.year }}</button>
                    </div>
                </div>
                <div class="col-6" :style="!loading && selecteddayData.data[0].length>0?'display:inline-block;':'display:none;'">
                    <div class="hiddenstart hidden">
                        <button id="scrolldays" type="button" class="btn btn-primary setmargin5" @click="rundays">Rullaa</button>
                        <hr>
                        <p class="graphtitle">{{ dailycharttitle }}</p>
                        <div id="daygraph"></div>
                    </div>
                </div>
            </div>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph10" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph4" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph12" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph2" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles":title="''" :elemid="testgraph3" :active=true></trendgraph>
            <monthtable :title="'Kuukausittaiset lämpötilat'" :monthlydata="calculated.values.yearlyvalues" :monthaverages="calculated.values.monthlyvalues.temperature" :monthnames="monthnames" :datatype="'t'"></monthtable>
            <monthtable :title="'Kuukausittaiset lämpötilaerot'":monthlydata="calculated.values.yearlyvalues" :monthaverages="calculated.values.monthlyvalues.diff" :monthnames="monthnames" :datatype="'d'"></monthtable>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph11" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph5" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph6" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph7" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph8" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph9" :active=true></trendgraph>

<!-- Latest readings modal start---------------------------------------------------------- -->
            <div id="loadModal" class="modal fade" tabindex="-1" aria-labelledby="loadModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="loadModalLabel">Viimeisimmät lukemat</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div id="loader3" class="loader hidden"></div>

                            <table class="latestreadingtable">
                                <tr>
                                    <th>Päivä</th><th>Aamu</th><th>Ilta</th><th>Aamu</th><th>Ilta</th>
                                </tr>
                            <tr v-for="item in latestReadingsFromNet">
                                <td>{{ isNaN(item.observation.morning) ?  item.observation.eveningtime.getDate() : item.observation.morningtime.getDate() }}.
                                    {{ isNaN(item.observation.morning) ?  item.observation.eveningtime.getMonth()+1: item.observation.morningtime.getMonth()+1 }}.
                                    {{  isNaN(item.observation.morning) ?  item.observation.eveningtime.getFullYear(): item.observation.morningtime.getFullYear()}}</td>
                                <td>{{ isNaN(item.observation.morning) ? '' : this.roundNumber(item.observation.morning, 1) }}</td>
                                <td>{{ isNaN(item.observation.evening) ? '' : this.roundNumber(item.observation.evening, 1) }}</td>
                                <td :class="this.getclass(item.reading.morning, item.observation.morning)">
                                    {{ this.printvalue(item.reading.morning, item.observation.morning) }}</td>
                                <td :class="this.getclass(item.reading.evening, item.observation.evening)">
                                    {{ this.printvalue(item.reading.evening, item.observation.evening) }}</td>
                                <td><input v-model="item.obsselected" :disabled="daydisabled(item)" type="checkbox" name="select"></td>
                            </tr>
                            </table>
                        </div>
                        <div class="modal-footer">
                            <input type="checkbox" :disabled="!latestReadingsFromNet.saveenable" name="saveyeartemperatures">
                            <button  :disabled="!latestReadingsFromNet.saveenable || !latestReadingsFromNet.find(l => l.obsselected)" @click="savereadings" type="button" class="btn btn-success">Tallenna</button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Sulje</button>
                        </div>
                    </div>
                </div>
            </div>
<!-- Latest readings modal end----------------------------------------------------------- -->

        </div>
    </div>
    <script type="module">

        import { createApp, ref } from 'vue'

        const months1 = ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'];
        const months2 = ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'];
        const NoSelection = -1;
        const StopScrolling = -2;
        let userguid = '';
        let givenyears = null;

        function selectFirstDay() {
            let button = document.getElementsByClassName('daybutton_0');
            if (button && button.length) button[0].click();
            else setTimeout(() => { selectFirstDay(); }, 50);
        }

        (async function () {
            userguid = new URLSearchParams(document.location.search).get("userid");
            const years = new URLSearchParams(document.location.search).get("years");
            if (years === null) givenyears = null;
            else {
                const yearlist = years.split(',')
                givenyears = {data: yearlist.map(y => Number(y))};
            }

            setTimeout(() => { selectFirstDay(); }, 50);
        })();
        
        const vueapp = createApp({
            data() {
                return {
                    defaultyear: 1976,
                    monthnames: months1,
                    monthnamesLong: months2,
                    givenyears: givenyears,

                    loading: ref(true),
                    
                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    testgraph9: 'GraphLocation9',
                    testgraph10: 'GraphLocation10',
                    testgraph11: 'GraphLocation11',
                    testgraph12: 'GraphLocation12',
                    testgraphtitles : [],

                    scrollday: {
                        firstdate: null,
                        selecteddate: null,
                        selecteddayindex: NoSelection,
                        scroll: false,
                    },
                    selectedday: 0, // not used
                    selecteddayData: {data: [[],[]], chart: null},

                    calculated : {
                        values: {yearlyvalues: [], monthlyvalues: []},
                    },

                    alltemperaturereadings: { values: [], years: [], filtersize: 7 },    // all temperature values
                    listedtemperaturereadings: { values: [], years: [], filtersize: 7 }, // contains values listed in table
                    last20Temperatures: [],
                    latestReadingsFromNet: [],
                    dailycharttitle: '',

                    screenCharts: [],
                    selectedyearbutton: '',
                    monthlylimits: [],
                }
            },
            async mounted() {
                await this.loadAll()
            },
            components: {
                readings: {
                    props: ['temperatures', 'selectedday', 'allreadings'],
                    emits: ['dayselected', 'savefile'],
                    data: function () {
                        return {
                            selected: ref(NoSelection),
                            sum: ref(0),
                            arrowup: String.fromCharCode(0x2191),
                            arrowdn: String.fromCharCode(0x2193),
                        }
                    },
                    // reading
                    computed: {
                        calculateAverage: function () {
                            this.sum = 0;
                        }
                    },
                    // reading
                    methods: {
                        // reading
                        setSum(value) {
                            this.sum = value;
                        },
                        // reading
                        roundNumber(value, num) {
                            return roundNumber(value, num)
                        },
                        // reading
                        calcSums() {
                            let setvalue = this.setSum;
                            setTimeout(function () {
                                let elements = document.getElementsByClassName('xxx active');
                                if (elements.length == 0) {
                                    setvalue(0);
                                    return;
                                }
                                let sum = 0;
                                let count = 0;
                                for (var index = 0; index < elements.length; index++) {
                                    if (isNumeric(elements[index].innerText)) {
                                        sum += Number(elements[index].innerText);
                                        count++;
                                    }
                                }
                                if (count > 0) setvalue(sum / count);
                                else setvalue(-1);
                            }, 1)
                        },
                        // reading
                        getDateTxt(date) {
                            return getDateTxt(date);
                        },
                        // reading
                        selectDay(item) {
                            if (this.selected == item.index) this.selected = NoSelection;
                            else this.selected = item.index;
                            this.calcSums();
                            if (this.selected == item.index) {
                                const selecteddate = this.temperatures.values[this.selected].date.getDate();
                                const selectedmonth = this.temperatures.values[this.selected].date.getMonth();
                                let values = this.allreadings.values.map(r => {
                                    if (r && r.date && r.date.getDate() == selecteddate && r.date.getMonth() == selectedmonth) {
                                        return {date: r.date, value: r.average, morning: r.morning, evening: r.evening, datetimeLocal: r.date}
                                    }
                                    else return null
                                })
                                this.$emit('dayselected', {values: values.filter(v => v !== null), selected: this.selected});
                            }
                            else this.$emit('dayselected', {values: [], selected: StopScrolling});
                        },
                        // reading
                        markIfPressed(item) {
                            if (this.selected < 0) return { active: false };
                            if (this.selected == item.index) return { active: true }
                            return { active: false };
                        },
                        // reading
                        getClass(index) {
                            return `daybutton_${index}`;
                        },
                        // reading
                        markIfSelected(item, mode) {
                            if (this.selected < 0) return { active: false, 
                                morninghigh: (mode == 1 && item.morninghighest), morninglow: (mode == 1 && item.morninglowest),
                                eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest) 
                            };
                            return { active: item.date >= this.temperatures.values[this.selected].firstdayfilter &&
                                    item.date < this.temperatures.values[this.selected].lastdayfilter, 
                                    morninghigh: mode == 1 && item.morninghighest, morninglow: mode == 1 && item.morninglowest,
                                    eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest)  }
                        },
                        // reading
                        saveValuestoFile() {
                            let data = this.allreadings.values.map(line => (
                                `${this.getDateTxt(line.date)}\t${roundNumber(line.morning, 1)}\t${roundNumber(line.evening, 1)}\t${roundNumber(line.averagefiltered, 1)}`
                            ));
                            let filename = 'readings.txt';
                            //this.saveToFile(`Päivämäärä\tAamu\tIlta\tSuodatettu(${this.allreadings.filtersize})\n${data.join('\n')}`, filename, `Tallennettu tiedostoon ${filename}`, '');
                            this.$emit('savefile', {data: `Päivämäärä\tAamu\tIlta\tSuodatettu(${this.allreadings.filtersize})\n${data.join('\n')}`,
                                filename: filename, message: `Tallennettu tiedostoon ${filename}`});
                        },
                    },
                    // reading
                    template: `
                        <p class="graphtitle">Mittaustulokset ja suodatettu arvo</p>
                        <div><button type="button" class="btn btn-primary" @click="saveValuestoFile">Tallenna kaikki lukemat tiedostoon</button></div>
                        <div class="scrollbox">
                        <table class="datatable">
                            <thead><tr><td></td><td>Aamu</td><td>Ilta</td><td>Suod({{temperatures.filtersize}})</td><td class="hideifnarrow">Keskiarvo</td></tr></thead>
                            <tbody>
                                <tr v-for="(item, index) in temperatures.values">
                                    <td :class="markIfPressed(item)" align="center"> 
                                        <button class="actionbutton" @click="selectDay(item)" :class="markIfPressed(item),getClass(index)">
                                            {{ getDateTxt(item.date) }} 
                                        </button> 
                                    </td>
                                    <td class="xxx" :class="markIfSelected(item, 1)"> {{ roundNumber(item.morning, 1) }}{{ item.morninghighest ? this.arrowup : "" }}{{ item.morninglowest ? this.arrowdn : "" }}</td>
                                    <td class="xxx" :class="markIfSelected(item, 2)"> {{ roundNumber(item.evening, 1) }}{{ item.eveninghighest ? this.arrowup : "" }}{{ item.eveninglowest ? this.arrowdn : "" }} </td>
                                    <td :class="markIfPressed(item)"> {{ roundNumber(item.averagefiltered, 1) }} </td>
                                    <td class="xxx hideifnarrow" :class="markIfSelected(item, 2)"> {{ roundNumber(item.average, 1) }} </td>
                                </tr>                                
                            </tbody>
                        </table>            
                        </div>            
                        `
                },
                monthtable: {
                    props: ['monthlydata', 'monthnames', 'monthaverages', 'title', 'datatype'],
                    emits: ['lastyear'],
                    // monthtable
                    methods: {
                        roundNumber(value, num) {
                            return roundNumber(value, num);
                        },
                        getTableTemperatureValue(m) {
                            if (isNaN(m.temperature)) return '-'
                            return `${m.estimate ? '(' : ''}${roundNumber(m.temperature, 1)}${m.estimate ? ')' : ''}`;
                        },
                        getTableDifferenceValue(m) {
                            if (isNaN(m.difference)) return '-'
                            return `${m.estimate ? '(' : ''}${roundNumber(m.difference, 1)}${m.estimate ? ')' : ''}`;
                        },
                    },
                    // monthtable
                    template: `
                        <hr>
                        <div class="hiddenstart hidden">
                        <p class="graphtitle">{{ title }}</p>
                        <table class="datatable">
                            <thead>
                                <tr>
                                    <th></th><th v-for="month in monthnames">{{ month }}</th>
                                    <th>Koko vuosi</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in monthlydata">
                                    <td>{{ item.year }}</td> 
                                    <td v-for="m in item.months">{{ datatype=="t" ? getTableTemperatureValue(m) : getTableDifferenceValue(m) }}</td>
                                    <td>{{ item.estimate===true ? '(': ''}}{{ datatype=="t" ? roundNumber(item.yearaverage, 1): roundNumber(item.yearaveragediff, 1) }}{{ item.estimate==true?')':''}}</td>
                                </tr>                                
                            </tbody>
                            <tfoot>
                                <tr>
                                    <th>Yht</th>
                                    <th v-for="value in monthaverages">{{ roundNumber(value,1) }}</th>
                                </tr>
                            </tfoot>
                        </table>
                        </div>
                        `
                },
                trendgraph: {
                    props: ['title', 'elemid', 'active', 'titles'],
                    template: `
                        <hr>
                        <div>
                            <p class="graphtitle">{{ titles[elemid] ? titles[elemid] : '' }}</p>
                            <div :class="{hidden: !active}" class="trendchart">
                                <div class="trendtitle"></div>
                                <div :id="elemid" class="graphelement"></div>
                            </div>
                        </div>
                        `
                }
            },
            methods: {
                async loadAll() {
                    this.startSpinner(1);
                    let years = null;
                    if (this.givenyears === null) years = await apiGetYears(userguid, 'Salo');
                    else years = this.givenyears;
                //years.data = [2024]
                let temperatures = await apiGetTemperatures(userguid, "Salo", years.data);
                if (temperatures.error)  {
                    this.stopSpinner(1);
                    document.getElementById('Error').innerText = temperatures.error.msg;
                    return;
                }
                this.checkData(temperatures);
                this.last20Temperatures = this.getLastreadings(temperatures);
                if (this.last20Temperatures.length == 0) {
                    this.stopSpinner(1);
                    document.getElementById('Error').innerText = "Ei lämpötilalukemia";
                    return;
                }
                const data = await apiAdminButton1(userguid);
                if (data.statusCode == 200) {
                    const elem = document.getElementById('hiddenbutton');
                    if (elem) elem.innerHTML = data.data.html;
                }
                // initialize temperature readings
                CFinitTemperature(temperatures, this.alltemperaturereadings.filtersize, this.monthnames, this.monthnamesLong);

                this.alltemperaturereadings = CFgetAllReadings();
                this.listedtemperaturereadings.filtersize = this.alltemperaturereadings.filtersize;
                this.listedtemperaturereadings.values = [];
                const temp = this.alltemperaturereadings.values.map((v, i) => ({year: v.date.getFullYear(), index: i}));
                let prev = '';
                this.listedtemperaturereadings.years = temp.filter(v => { let returnvalue = v.year != prev; prev = v.year; return returnvalue;});
                this.fillTemperaturereadingtable(0, this.listedtemperaturereadings.values, this.alltemperaturereadings.values[0].date.getFullYear(), this.stoploading);

                // initialize graphics curves
                this.calculated.values = CFcalculateMonthlyAverages();
                this.monthlylimits = this.calculated.values.monthlystatvalues;


                this.createChart(this.testgraph10, 'Suodatetut lämpötilat', temperatures, CFcreateYearlyFilteredSeriedata);
                this.createChart(this.testgraph2, 'Päivittäiset keskiarvot', temperatures, CFcreateAllYearsAverageSeriedata);
                this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', temperatures, CFcreateAllYearsMonthlyAverageSeriedata);
                this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', temperatures, CFcreateAllYearsFilteredSeriedata);
                this.createChart(this.testgraph4, 'Viimeinen vuosi', temperatures, CFcreateLastYearsSeriedata);
                this.createChart(this.testgraph9, 'Aamun ja illan ero (suodatettu)', temperatures, CFcreateDailyDiffdata);
                this.createChart(this.testgraph12, 'Korkeimmat ja matalimmat arvot/vuosi (kpl)', temperatures, CFcreateYearlyHighValuedata);
                this.createChart(this.testgraph11, 'Vuosittainen suuntaus', temperatures, CFcreateYearlyTrendSeriedata);

                this.screenCharts.push(this.createChart(this.testgraph5, 'Kesän suuntaus', temperatures, CFcreateMonthlySummerTrendSeriedata));
                this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                this.screenCharts.push(this.createChart(this.testgraph6, 'Talven suuntaus', temperatures, CFcreateMonthlyWinterTrendSeriedata));
                this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                this.screenCharts.push(this.createChart(this.testgraph7, 'Syksyn suuntaus', temperatures, CFcreateMonthlyFallTrendSeriedata));
                this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                this.screenCharts.push(this.createChart(this.testgraph8, 'Kevään suuntaus', temperatures, CFcreateMonthlySpringTrendSeriedata));
                this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                let itemlist = document.querySelectorAll(".hiddenstart.hidden");
                if (itemlist && itemlist.length) itemlist.forEach(i => i.classList.remove("hidden"))

                this.stopSpinner(1);

                setTimeout(() => {
                    let elem = document.getElementById('loadModal');
                    if (elem) {
                        elem.addEventListener('show.bs.modal', async () => {
                            // get latest readings when modal opened
                            this.startSpinner(3);
                            const stationreadings = await apiGetLatestTemperatures();
                            //const stationreadings = debugdata;
                            
                            // Debug data
                            /*
                            let values = [];
                            
                            let day = 28;
                            for (var i = 0; i < 10; i++) {
                                values.push({
                                    localtime: (day > 20 ? "202412" : "202501") +   (day < 10 ? '0' : '') + day.toString() + "T070000",
                                    name: "Kärkkä",
                                    t2m: i,
                                })
                                values.push({
                                    localtime: (day > 20 ? "202412" : "202501") +   (day < 10 ? '0' : '') + day.toString() + "T150000",
                                    name: "Kärkkä",
                                    t2m: i+0.5,
                                })
                                day++;
                                if (day > 31) day = 1;
                            }
                            stationreadings.observations = stationreadings.observations.concat(values);
                            */

                            this.latestReadingsFromNet = compareReadings(this.last20Temperatures, stationreadings);
                            const saving = await apiGetSavingAllowed(userguid);
                            this.latestReadingsFromNet.saveenable = saving.data.access;

                            this.stopSpinner(3);
                        });
                    }
                }, 10);

                },
                stoploading() {
                    this.loading = false;
                },
                mainpage() {
                    window.location.href = `./charts.html?${userid === null ? '' : userid=userid + '&'}years=${yearparams}`;
                },
                roundNumber(value, num) {
                    return roundNumber(value, num)
                },
                startSpinner(no) {
                    const elem = document.getElementById(`loader${no}`);
                    if (elem) elem.classList.remove('hidden');
                },
                stopSpinner(spinnerno) {
                    if (spinnerno) {
                        const elem = document.getElementById(`loader${spinnerno}`);
                        if (elem) elem.classList.add('hidden');
                    }
                    const elems = document.getElementsByClassName('loader')
                    if (elems) {
                        for (var i = 0; i < elems.length; i++) elems[i].classList.add('hidden');
                    }
                },     
                getclass(reading, observation) {
                    return isNaN(observation) ? (isNaN(reading) ? '' : 'estimatedvalue') : 
                                    !isNaN(reading) && reading != observation ? 'diffvalue' : '' 
                },
                printvalue(reading, observation) {
                    return isNaN(reading) ? '' : this.roundNumber(reading, isNaN(observation) ? 0 : 1)
                },
                daydisabled(item) {
                    let selected = this.latestReadingsFromNet.find(i => i.obsselected);
                    if (selected != null) {
                        if (selected.date.getFullYear() != item.date.getFullYear()) return true;
                    };

                    if (((!isNaN(item.observation.morning) && isNaN(item.reading.morning)) ||
                        (!isNaN(item.observation.evening) && isNaN(item.reading.evening))) == true) {
                        return false;
                    }
                    if (!isNaN(item.observation.morning) && !isNaN(item.reading.morning)) {
                        if (item.observation.morning !== item.reading.morning) return false;
                    }
                    if (!isNaN(item.observation.evening) && !isNaN(item.reading.evening)) {
                        if (item.observation.evening !== item.reading.evening) return false;
                    }
                    return true;
                },
                savefile(params) {
                    this.saveToFile(params.data, params.filename, params.message, '')
                },
                saveToFile(dataToSave, fileName, successmsg, eventname) {
                    var gameblob = new Blob([dataToSave], { type: 'text/plain' })
                    if (this.objUrl !== null) window.URL.revokeObjectURL(this.objUrl);
                    this.objUrl = (window.webkitURL || window.URL).createObjectURL(gameblob);
                    var anchor = document.createElement('a');
                    anchor.download = fileName;
                    anchor.href = this.objUrl;
                    anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
                    anchor.click();
                    // document.querySelector("body").dispatchEvent(
                    //     new CustomEvent(eventname, {
                    //         bubbles: true,
                    //         detail: { text: () => successmsg },
                    //     })
                    // );
                },                
                createDbDate(date)  {
                    return `${date.getMonth()+1}/${date.getDate()}/${date.getFullYear()}`;
                },
                async savereadings() {
                    let tobesaved = this.latestReadingsFromNet.map(l => l.obsselected ? 
                        {date: this.createDbDate(l.date), morning: l.observation.morning, evening: l.observation.evening, morningtime: l.observation.morningtime, eveningtime: l.observation.eveningtime}
                         : null).filter(a => a !== null);

                    if (tobesaved.length && this.latestReadingsFromNet.saveenable) {
                        // save selected readings
                        let status = await apiSaveReadings(userguid, userguid, tobesaved);
                        if (status.statusCode == 200) {
                            if (status.data.msg.saved == true) {
                                bootstrap.Modal.getInstance(document.getElementById('loadModal')).hide();
                                await this.loadAll();
                                let elems = document.getElementsByName("saveyeartemperatures");
                                if (elems && elems.length) {
                                    if (elems[0].checked == true && status.data.msg.record.length) {
                                        this.saveToFile(JSON.stringify(status.data.msg.record[0].readings, null, 4), 'LatestRecord.json', 'Tallennus tehty', '');
                                    }
                                }
                            }
                            else {

                                alert(`Not saved, Debugging on`)
                            }
                        }
                        else alert(`Debugging on: ${status.data.msg}`)
                    }
                },
                showselectedyear(item) {
                    this.dayselected({selected: NoSelection, values: []});
                    this.startSpinner(2);
                    this.listedtemperaturereadings.values = [];
                    setTimeout( () => {this.fillTemperaturereadingtable(item.index, this.listedtemperaturereadings.values, this.alltemperaturereadings.values[item.index].date.getFullYear(), this.stopSpinner)}, 10);
                },
                fillTemperaturereadingtable(index, desttable, year, stopFunc) {
                    const maxyears = 2;
                    let i;
                    let counter = 0;
                    for (i = index; i < this.alltemperaturereadings.values.length && i < index + 1000 && this.alltemperaturereadings.values[i].date.getFullYear() > year-maxyears;i++) {
                        desttable.push(this.alltemperaturereadings.values[i]);
                        desttable[desttable.length-1].index = counter++;
                    }
                    this.selectedyearbutton = year.toString();
                    if (i < this.alltemperaturereadings.values.length && this.alltemperaturereadings.values[i].date.getFullYear() > year-maxyears) setTimeout(fillTemperaturereadingtable, 200, i, desttable, year);
                    else stopFunc();
                },
                monthlytrendcallback(params) {
                    const seriestatus = Object.keys(params.selected).map(k => ({status: params.selected[k], name: k}));
                    let i = 0;
                    let chart = null;
                    while (!chart && i < this.screenCharts.length) {
                        let j = 0;
                        while (j < this.screenCharts[i].serieOptions.series.length && !chart) {
                            // only one serie cheked, maybe should be more
                            let search = seriestatus.find(s => this.screenCharts[i].serieOptions.series[j].trend == false && this.screenCharts[i].serieOptions.series[j].name == s.name);
                            if (search) chart = this.screenCharts[i];
                            else j++;
                        }
                        if (!chart) i++;
                    }
                    if (!chart) return;

                    const series = chart.serieOptions.series.map(d => {
                        let search = seriestatus.find(s => s.name == d.name);
                        if (!d.trend && search && search.status === true) {
                            // serie active
                            return {
                                name: d.name,
                                num: d.num,
                                data: d.data.map(val => ({
                                    value: isNumeric(val.value[1]) ? Number(val.value[1]) : NaN,
                                    year:  val.value[0].getFullYear(),
                                }))
                            }
                        }
                        return null;
                    }).filter(v => v !== null);

                    const originaltrendserie = chart.serieOptions.series.find(d => d.trend == true);
                    if (!originaltrendserie) return;
                    const tempserie = {data: chart.serieOptions.series[0].data.map(ss => ({info: {year: ss.value[0].getFullYear(), location: ''}}))};
                    const temp = createTrendForGivenMonths(series.map(s => s.num), series.map(s => s.name));
                    const datavalues = temp.values;
                    const newtrendserie = datavalues.find(d => d.trend == true);
                    if (!newtrendserie) return;
                    originaltrendserie.data = newtrendserie.values.map(v => v);
                    originaltrendserie.name = newtrendserie.name;
                    chart.trendChart.setOption(chart.serieOptions);
                },                
                checkData(temperatures) {
                    temperatures.data.forEach(t => {
                        const year = t.info.year;
                        let prevdate = 0;
                        t.data.forEach(d => {
                            if (d.datetimeLocal.getFullYear() !== year) {
                                alert(`Invalid year ${d.date.getFullYear()}`);
                            }
                            if (prevdate >= d.datetimeLocal) {
                                alert(`Invalid date ${d.datetimeLocal.getDate(0)}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`);
                            }
                            prevdate = d.datetimeLocal;
                        })
                    })
                },
                //------------------------------------------------------------------------------
                createChart(element, title, data, funct, thischart) {
                    this.testgraphtitles[element] = title;
                    let trendChart = (thischart ? thischart.trendChart : this.initSerie(element));
                    if (trendChart === null) return;
                    const buildValues = funct(data);
                    const params = buildValues.params;
                    let serieOptions = this.buildChartOptions(title, buildValues);

                    trendChart.setOption(serieOptions);
                    return {trendChart, serieOptions, params};
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                getMinMaxValue(series) {
                    let min = getTempMinDefaultValue();
                    let max = getTempMaxDefaultValue();
                    series.data.forEach(s => {
                        s.values.forEach(point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return { min: min, max: max }
                },
                getSelection(seriedata, selectedseries) {
                    let selection = {};
                    seriedata.data.forEach(s => {
                        selection[s.name] = false;
                    })
                    if (selectedseries && selectedseries.length) {
                        selectedseries.forEach(s => {
                            selection[s] = true;
                        })
                    }
                    return selection;
                },                
                buildChartOptions(title, series) {
                    const monthnames = this.monthnames;
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: '',//title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function (value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (series.params && series.params.legend && series.params.legend.items) {
                                        return series.params.legend.items[m];
                                    }
                                    if (y < 1978) return monthnames[m];
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series, series.params),
                        legend: {
                            show: false,
                            textStyle: { color: '#f0f', fontSize: '16' },
                        },
                    };
                    if (series.params) {
                        if (series.params.rangeoffset != null) {
                            let minmax = this.getMinMaxValue(series);
                            let offset = Number(series.params.rangeoffset);
                            chartoptions.yAxis.min = roundNumber(minmax.min - offset - 1, 0);
                            chartoptions.yAxis.max = roundNumber(minmax.max + offset, 0);
                        }
                        if (series.params.rangemin != null) {
                            chartoptions.yAxis.min = series.params.rangemin;
                        }
                        if (series.params.rangemax != null) {
                            chartoptions.yAxis.max = series.params.rangemax;
                        }
                        if (series.params.showlegend) {
                            chartoptions.legend.show = true;
                        }
                        if (series.params.selection) {
                            chartoptions.legend.selected = this.getSelection(series, series.params.selection);
                        }
                    }

                    return chartoptions;
                },
                //------------------------------------------------------------------------------
                dayselected(data) {
                    this.selectedday = data.selected;
                    // create trend curve
                    if (data.selected >= 0 || data.selected == StopScrolling) {
                        this.scrollday.selecteddayindex = data.selected;
                        this.stopdays();
                    }
                    const values = {
                        data: data.values.map(d => ({
                            value: d.value,
                            year: d.date.getFullYear(),
                            date: d.date,
                        }))
                    }
                    const factors = CFcalculateTrend([values]);
                    let trend = data.values.map(d => ({
                        value: d.date.getFullYear() * factors.k + factors.b,
                        date: d.date,
                    }))
                    let series = [data.values, trend];
                    this.selecteddayData.data = series;
                    this.dailycharttitle = `Päivän ${values.data.length ? values.data[0].date.getDate() : ''}.${values.data.length ? values.data[0].date.getMonth()+1 : ''} vuosittaisarvot (${factors.k > 0 ? '+' : ''}${roundNumber(factors.k * 10, 1)}°C/10v)`;

                    this.selecteddayData.chart = this.createChart('daygraph', 
                        this.dailycharttitle, series, this.createDayGraph, this.selecteddayData.chart);
                },
                rundays() {
                    if (this.scrollday.scroll == false) {
                        let elem = document.getElementById('scrolldays');
                        elem.innerText='Lopeta rullaus';
                        this.scrollday.scroll = true;
                        this.scrollday.firstdate = this.scrollday.selecteddate = this.listedtemperaturereadings.values[this.scrollday.selecteddayindex].date;
                        setTimeout(this.scrolldayfunction, 1);
                    }
                    else {
                        this.stopdays();
                    } 
                },
                stopdays() {
                    let elem = document.getElementById('scrolldays');
                    elem.innerText='Rullaa';
                    this.scrollday.scroll = false;
                    this.scrollday.selecteddate = this.scrollday.firstdate = null;
                },
                scrolldayfunction() {
                    if (this.scrollday.selecteddate === null) return;

                    let newday = new Date(this.scrollday.selecteddate.getFullYear(), this.scrollday.selecteddate.getMonth(), this.scrollday.selecteddate.getDate() - 1);
                    if (newday <= new Date(this.scrollday.firstdate.getFullYear() - 1, this.scrollday.firstdate.getMonth(), this.scrollday.firstdate.getDate())) {
                        this.scrollday.selecteddate =  this.scrollday.firstdate;
                    }
                    else this.scrollday.selecteddate = newday;

                    const selecteddate = this.scrollday.selecteddate.getDate();
                    const selectedmonth = this.scrollday.selecteddate.getMonth();
                    let values = this.alltemperaturereadings.values.map(r => {
                        if (r && r.date && r.date.getDate() == selecteddate && r.date.getMonth() == selectedmonth) {
                            return {datetimeLocal: r.date, date: r.date, value: r.average, morning: r.morning, evening: r.evening}
                        }
                        else return null
                    }).filter(v => v !== null);

                    this.dayselected({values: values, selected: NoSelection});
                    setTimeout(this.scrolldayfunction, 200);
                },
                getDateTxt(date, daymonth) {
                    return getDateTxt(date, daymonth == true ? true : false);
                },
                createSeries(series, params) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 4,
                        symbol: 'circle',
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                        trend: values.trend,
                        num: values.index,
                    }))

                    if (params) {
                        if (params.series) {
                            params.series.forEach(p => {
                                if (p.name == '') {
                                    // apply to all series
                                    if (p.markersize !== undefined) {
                                        chartdata.forEach(chart => {
                                            chart.symbolSize = p.markersize;
                                        })
                                    }
                                }
                            })
                            chartdata.forEach(d => {
                                let found = params.series.filter(p => p.name === d.name);
                                if (found && found.length) {
                                    d.symbolsize = 1;
                                    if (found.color) d.lineStyle = { color: found.color }

                                    if (found.symbolindex == 'last') {
                                        if (d.data.length) {
                                            d.data[d.data.length-1].symbol = found.symbol;
                                            d.data[d.data.length-1].symbolSize = found.symbolsize;
                                        }
                                    }
                                    else {
                                        let i = 0;
                                        while (i < found.length) {
                                            if (d.data[found[i].symbolindex]) {
                                                if (found[i].symbol) d.data[found[i].symbolindex].symbol = found[i].symbol;
                                            }
                                            if (d.data[found[i].symbolindex]) {
                                                if (found[i].symbolsize) d.data[found[i].symbolindex].symbolSize = found[i].symbolsize;
                                            }
                                            i++;
                                        }
                                    }
                                }
                            })
                        }
                    }
                    return chartdata;
                },
                createDayGraph() {
                    let datavalues = [];
                    this.selecteddayData.data.forEach((serie, i) => {
                        let values = serie.map(dd => (
                            {value: [dd.date, dd.value], tooltip: `Päivä: ${this.getDateTxt(dd.date, false)} ${roundNumber(dd.value, 1)}`}
                        ))
                        datavalues.push({values: values, location: '', year: 0});
                    });
                    const month =  datavalues.length > 0 && datavalues[0].values.length > 0 ?  datavalues[0].values[0].value[0].getMonth() : -1;
                    let limits = month >= 0 ? this.monthlylimits[month] : {min: -20, max: 20};
                    return {data: datavalues, params: {rangemin: limits.min, rangemax: limits.max}}
                },
                getLastreadings(temperatures) {
                    const lasttemperaturesamount = 20;
                    let last20Temperatures = [];
                    if (temperatures.data.length <= 0 ) return [];
                    if (temperatures.data.length > 1 && temperatures.data[temperatures.data.length - 1].data.length < lasttemperaturesamount) {
                        let last = temperatures.data[temperatures.data.length - 2].data.length;
                        const first = last - (lasttemperaturesamount - temperatures.data[temperatures.data.length - 1].data.length)
                        for (var i = first; i < last; i++) {
                            last20Temperatures.push(temperatures.data[temperatures.data.length - 2].data[i]);
                        }
                        for (var i = 0; i < temperatures.data[temperatures.data.length - 1].data.length; i++) {
                            last20Temperatures.push(temperatures.data[temperatures.data.length - 1].data[i]);
                        }
                    }
                    else {
                        let first = temperatures.data[temperatures.data.length - 1].data.length - lasttemperaturesamount;
                        for (var i = first; i < temperatures.data[temperatures.data.length - 1].data.length; i++) {
                            last20Temperatures.push(temperatures.data[temperatures.data.length - 1].data[i]);
                        }
                    }
                    return last20Temperatures;
                },

                //-end of methods-----------------------------------------------------------------------------
            }
        }).mount('#app');

    </script>

</body>

</html>