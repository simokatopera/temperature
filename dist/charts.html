<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilat</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <style>
        .graphelement {
            width: 1200px;
            height: 380px;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilakäyrät</h1>
        </div>
        <div id="app" class="page-content">
            <trendgraph :active="false" :elemid="testgraph10" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph4" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph2" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph" :title="trendtitles"></trendgraph>
            <monthtable :monthlydata="months"></monthtable>
            <trendgraph :active="false" :elemid="testgraph3" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph5" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph6" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph7" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph8" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph9" :title="trendtitles"></trendgraph>
        </div>
    </div>
    <script type="module">

        import { createApp, ref } from 'vue'

        (async function () {


        })();



        const vueapp = createApp({
            data() {
                return {
                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    testgraph9: 'GraphLocation9',
                    testgraph10: 'GraphLocation10',
                    trendtitles: [],
                    calculatedMonthlytrends: [],
                    calculatedDailyAverages: [],
                    defaultyear: 1976,
                    months: []
                }
            },
            async mounted() {
                let years = await apiGetYears('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', 'Salo');
                let temperatures = await apiGetTemperatures('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', "Salo", years.data);

                this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', temperatures, this.createAllYearsMonthlyAverageSeriedata);
                this.createChart(this.testgraph10, 'Suodatetut lampotilat', temperatures, this.createAllYearsFilteredSeriedata);
                this.createChart(this.testgraph2, 'Päivittäinen keskiarvo', temperatures, this.createAllYearsAverageSeriedata);
                this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', temperatures, this.createAllYearsSeriedata);
                this.createChart(this.testgraph4, 'Viimeinen vuosi', temperatures, this.createLastYearsSeriedata);
                this.createChart(this.testgraph5, 'Kesän suuntaus', temperatures, this.createMonthlySummerTrendSeriedata);
                this.createChart(this.testgraph6, 'Talven suuntaus', temperatures, this.createMonthlyWinterTrendSeriedata);
                this.createChart(this.testgraph7, 'Syksyn suuntaus', temperatures, this.createMonthlyFallTrendSeriedata);
                this.createChart(this.testgraph8, 'Kevään suuntaus', temperatures, this.createMonthlySpringTrendSeriedata);
                this.createChart(this.testgraph9, 'Aamun ja illan ero', temperatures, this.createDailyDiffdata);

                this.calculateMonthlyAverages(temperatures);
            },
            components: {
                monthtable: {
                    props: ['monthlydata'],
                    template: `
                        Taulukko
                        <table>
                            <thead><tr>Kuukausittaiset keskiarvot</tr></thead>
                            <tbody>
                                <tr v-for="item in monthlydata">
                                    <td>{{ item.year }}</td> 
                                </tr>                                
                            </tbody>
                        </table>
                        `
                },
                trendgraph: {
                    props: ['active', 'elemid', 'title'],
                    template: `
                        <div :class="{hidden: !active}" class="trendchart">
                            <div class="trendtitle"></div>
                            <div :id="elemid" class="graphelement"></div>
                        </div>
                        `
                }
            },
            methods: {
                createChart(element, title, temperatures, funct) {
                    let trendChart = this.initSerie(element);
                    if (trendChart === null) return;
                    let serieoptions = this.buildChartOptions(title, funct(temperatures));
                    trendChart.setOption(serieoptions);
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                //setSerie(id, data, chartdata) {
                //let serie = this.serieinfo.find((s) => s.id == id);
                //if (!serie) this.serieinfo.push({ id: id, data: data, chartdata: chartdata });
                //},
                getMinMaxValue(series) {
                    let min = 999999999;
                    let max = -999999999;
                    series.data.forEach(s => {
                        s.values.forEach(point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return { min: min, max: max }
                },
                buildChartOptions(title, series) {
                    const months = ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu']
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function (value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (series.params && series.params.legend && series.params.legend.items) {
                                        return series.params.legend.items[m];
                                    }
                                    if (y < 1978) return months[m];
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series, series.params),
                        legend: {
                            show: false,
                            // data: ['1','2','3']
                            //     data: series.data.map(s => s.year),
                            // //     inactiveColor: '#aaa',
                            textStyle: { color: '#f0f', fontSize: '16' },
                            //     type: 'scroll',
                            //     //orient: 'vertical',
                            //     //top: 0,
                            //     //right: 20,
                        },
                    };
                    if (series.params) {
                        if (series.params.rangeoffset) {
                            let minmax = this.getMinMaxValue(series);
                            let offset = Number(series.params.rangeoffset);
                            chartoptions.yAxis.min = this.roundNumber(minmax.min - offset - 1, 0);
                            chartoptions.yAxis.max = this.roundNumber(minmax.max + offset, 0);
                        }
                        if (series.params.showlegend) {
                            chartoptions.legend.show = true;
                        }
                        if (series.params.selection) {
                            chartoptions.legend.selected = this.getSelection(series, series.params.selection);
                        }
                    }

                    return chartoptions;
                },
                getDate(date) {
                    let parts = date.split('/');
                    if (parts && parts.length === 3) {
                        return new Date(parts[2], Number(parts[0]) - 1, parts[1]);
                    }
                    return NaN;
                },
                getDateTxt(date, daymonth) {
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    if (daymonth) return `${day}.${month}`;
                    return `${day}.${month}.${year}`;
                },
                getDateTxtNoYear(date, daymonth) {
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    if (daymonth) return `${day}.${month}`;
                    return `${day}.${month}`;
                },
                createSeries(series, params) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 3,
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                    }))

                    if (params) {
                        if (params.series) {
                            params.series.forEach(p => {
                                if (p.name == '') {
                                    // apply to all series
                                    if (p.markersize !== undefined) {
                                        chartdata.forEach(chart => {
                                            chart.symbolSize = p.markersize;
                                        })
                                    }
                                }
                            })
                            chartdata.forEach(d => {
                                let found = params.series.find(p => p.name === d.name);
                                if (found) {
                                    //d.showSymbol = false;
                                    //d.symbol = 'none';
                                    d.symbolSize = 1;
                                    if (found.color) d.lineStyle = { color: found.color }
                                    // d.markPoint = {symbolSize: 0, opacity: 0};
                                }
                            })
                        }
                    }
                    return chartdata;
                },
                getReadingsBetween(startdate, enddate, series) {
                    if (startdate >= enddate) return [];

                    const startyear = startdate.getFullYear();
                    const endyear = enddate.getFullYear();

                    let startyearindex = 0;
                    while (series.data[startyearindex].info.year < startyear) startyearindex++;
                    let endyearindex = startyearindex;
                    while (series.data[endyearindex].info.year < endyear) endyearindex++;

                    let startdayindex = 0;
                    while (this.getDate(series.data[startyearindex].data[startdayindex].date) < startdate) startdayindex++;
                    let enddayindex = 0;
                    while (this.getDate(series.data[endyearindex].data[enddayindex].date) < enddate) enddayindex++;
                    let yearindex;
                    let dayindex;
                    let firstindex = startdayindex;
                    let readings = [];
                    for (yearindex = startyearindex; yearindex <= endyearindex; yearindex++) {
                        for (dayindex = firstindex; startyearindex === endyearindex ? dayindex < enddayindex : dayindex < series.data[yearindex].data.length; dayindex++) {
                            readings.push(series.data[yearindex].data[dayindex]);
                        }
                        firstindex = 0;
                    }
                    return readings;
                },
                findMin(dt, serie) {
                    let day = dt.getDate();
                    let month = dt.getMonth() + 1;
                    let value = serie.find(s => day == s.day && month == s.month);

                    return value.morning.min < value.evening.min ? {value: value.morning.min, date: value.morning.mindate} : {value: value.evening.min, date: value.evening.mindate};
                },
                findMax(dt, serie) {
                    let day = dt.getDate();
                    let month = dt.getMonth() + 1;
                    let value = serie.find(s => day == s.day && month == s.month);

                    return value.morning.max > value.evening.max ? {value: value.morning.max, date: value.morning.maxdate} : {value: value.evening.max, date: value.evening.maxdate};
                },
                createLastYearsSeriedata(series) {
                    const seriedata = {
                        data: null,
                        params: { showlegend: true, series: [{ name: 'Minimi', color: '#777777' }, { 'name': 'Maksimi', color: '#777777' }], legend: { items: ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'] } }
                    };
                    if (!series || !series.data || series.data.length == 0) {
                        return seriedata;
                    }
                    const lastdate = this.getDate(series.data[series.data.length - 1].data[series.data[series.data.length - 1].data.length - 1].date);
                    const firstdate = new Date(lastdate.getFullYear() - 1, lastdate.getMonth(), lastdate.getDate());
                    const readings = this.getReadingsBetween(firstdate, lastdate, series);

                    let morning = {};
                    let evening = {};
                    let minimum = {};
                    let maximum = {};
                    morning.values = readings.map(r => ({
                        value: [this.getDate(r.date), r.morning],
                        tooltip: `Aamu ${this.getDateTxt(this.getDate(r.date))} ${r.morning}`,
                    }));
                    morning.location = series.data[0].info.location;
                    morning.year = firstdate.getFullYear();
                    morning.name = "Aamu";
                    evening.values = readings.map(r => ({
                        value: [this.getDate(r.date), r.evening],
                        tooltip: `Ilta ${this.getDateTxt(this.getDate(r.date))} ${r.evening}`,
                    }));
                    evening.location = morning.location;
                    evening.year = lastdate.getFullYear();
                    evening.name = "Ilta";

                    // add minimum and maximum values to screen data
                    let sums = this.calculateDailyAverages(series);
                    maximum.values = morning.values.map(r => {
                        let value = this.findMax(r.value[0], sums);
                        return {
                            value: [r.value[0], value.value],
                            tooltip: `Maksimi ${this.getDateTxt(this.getDate(value.date))} ${value.value}`,
                        }
                    });
                    maximum.name = 'Maksimi';
                    minimum.values = morning.values.map(r => {
                        let value = this.findMin(r.value[0], sums);
                        return {
                            value: [r.value[0], value.value],
                            tooltip: `Minimi ${this.getDateTxt(this.getDate(value.date))} ${value.value }`,
                        }
                    });
                    minimum.name = 'Minimi';

                    seriedata.data = [morning, evening, minimum, maximum];

                    return seriedata;
                },
                createDailyDiffdata(series) {
                    let differencies = series.data.map(yearserie => ({
                        values: yearserie.data.map(s => {
                            let val = undefined;
                            let dt = new Date(s.datetimeUtc);
                            dt = new Date(this.defaultyear, dt.getMonth(), dt.getDate());
                            if (s.evening !== undefined && s.morning !== undefined) {
                                val = s.evening - s.morning;
                            }
                            return {
                                value: [dt, val],
                                tooltip: `${yearserie.info.location} ${new Date(s.datetimeUtc).getDate()}.${new Date(s.datetimeUtc).getMonth() + 1}.${new Date(s.datetimeUtc).getFullYear()} ${val === undefined ? '-' : this.roundNumber(val, 1)}°`,
                                datetimeUtc: s.datetimeUtc,
                            }
                        }),
                        location: yearserie.info.location,
                        year: yearserie.info.year,
                        name: yearserie.info.year.toString(),
                    }))
                    // create table for daily average calculation
                    let sums = [];
                    let dayindex;
                    let yearindex;
                    let index;
                    let value;

                    for (dayindex = 0; dayindex < 366; dayindex++) {
                        value = { date: new Date(this.defaultyear, 0, dayindex + 1), difference: { sum: 0, count: 0, average: NaN, min: 999999, max: -999999, maxday: null, minday: null }, day: 0, month: 0 };
                        value.month = value.date.getMonth() + 1;
                        value.day = value.date.getDate();
                        sums.push(value);
                    }
                    // calculate averages, fin mins and maxsis
                    let dayreadings;
                    let dt;
                    let month;
                    let day;
                    for (yearindex = 0; yearindex < differencies.length; yearindex++) {
                        for (dayindex = 0; dayindex < differencies[yearindex].values.length; dayindex++) {
                            dayreadings = differencies[yearindex].values[dayindex];
                            dt = new Date(dayreadings.datetimeUtc);
                            month = dt.getMonth() + 1;
                            day = dt.getDate();
                            let foundsum = sums.find(s => s.day == day && s.month == month);
                            if (foundsum) {
                                if (dayreadings.value[1] && this.isNumeric(dayreadings.value[1])) {
                                    foundsum.difference.count += 1;
                                    foundsum.difference.sum += dayreadings.value[1];
                                    if (dayreadings.value[1] < foundsum.difference.min) {
                                        foundsum.difference.min = dayreadings.value[1];
                                        const tempdate = new Date(dayreadings.datetimeUtc);
                                        foundsum.difference.minday = new Date(tempdate);
                                    }
                                    if (dayreadings.value[1] > foundsum.difference.max) {
                                        foundsum.difference.max = dayreadings.value[1];
                                        const tempdate = new Date(dayreadings.datetimeUtc);
                                        foundsum.difference.maxday = new Date(tempdate);
                                    }
                                }
                            }
                        }
                    }

                    // add average, minimum, maximum curves
                    let averagevalues = sums.map(daydata => {
                        let value = daydata.difference.count > 0 ? daydata.difference.sum / daydata.difference.count : NaN;
                        return {
                            value: [daydata.date, value],
                            tooltip: `Keskiarvo ${series.data[0].info.location} ${this.getDateTxtNoYear(daydata.date)} ${this.roundNumber(value, 1)}°`,
                        }
                    });
                    let averages = {
                        values: averagevalues,
                        location: series.data[0].info.location,
                        year: 0,
                        name: 'Keskiarvo'
                    };
                    differencies.push(averages);
                    let maximum = {
                        values: sums.map(daydata => ({
                            value: [daydata.date, daydata.difference.max],
                            tooltip: `Maksimi ${series.data[0].info.location} ${this.getDateTxt(daydata.difference.maxday)} ${this.roundNumber(daydata.difference.max, 1)}°`,
                        })),
                        location: series.data[0].info.location,
                        year: 0,
                        name: 'Maksimi',
                    };
                    differencies.push(maximum);
                    let minimum = {
                        values: sums.map(daydata => ({
                            value: [daydata.date, daydata.difference.min],
                            tooltip: `Minimi ${series.data[0].info.location} ${this.getDateTxt(daydata.difference.minday)} ${this.roundNumber(daydata.difference.min, 1)}°`,
                        })),
                        location: series.data[0].info.location,
                        year: 0,
                        name: 'Minimi',
                    };
                    differencies.push(minimum);
                    /*
                    let values = [];
                    values.push({value: [datetime, reading], tooltip: ''})

                    let datavalues = [];
                    datavalues.push({values: values, location: '', year: 2000})

                    return {data: datavalues, params: null}
                    */
                    // return values
                    const lastyear = series.data[series.data.length - 1].info.year;
                    const seriedata = {
                        data: differencies,
                        params: { showlegend: true, series: [{ name: 'Minimi', color: '#777777' }, { name: 'Maksimi', color: '#777777' }], selection: ['Maksimi', 'Minimi', 'Keskiarvo', lastyear] }
                    };
                    return seriedata;
                },
                createAllYearsSeriedata(series) {
                    let returnvalues = series.data.map(yearserie => ({
                        values: yearserie.data.map(s => ({
                            value: [this.getDate(s.date), s.morning],
                            tooltip: `${yearserie.info.location} ${this.getDateTxt(this.getDate(s.date))} ${s.morning}`,
                        })),
                        location: yearserie.info.location,
                        year: yearserie.info.year,
                    }))
                    const seriedata = {
                        data: returnvalues,
                        params: { series: [{ name: '', markersize: 1 }] }
                    };
                    return seriedata;
                },
                isNumeric(obj) {
                    return !Array.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
                },
                roundNumber(value, num) {
                    return value.toFixed(num);
                },
                calculateTrend(valuearray) {
                    let k = 0;
                    let b = 0;
                    let sumxy = 0;
                    let sumx = 0;
                    let sumy = 0;
                    let sumxsqr = 0;
                    let n = 0;
                    valuearray.forEach(values => {
                        values.data.forEach(reading => {
                            n++;
                            sumx += reading.year;
                            sumy += reading.value;
                            sumxy += reading.value * reading.year;
                            sumxsqr += reading.year * reading.year;
                        })
                    })
                    k = (n * sumxy - sumx * sumy) / (n * sumxsqr - sumx * sumx);
                    b = (sumy - k * sumx) / n;

                    return { k, b }
                },
                calculateMonthlyTrends(series) {
                    if (this.calculatedMonthlytrends.length > 0) return this.calculatedMonthlytrends;

                    let i;
                    let monthlyaverages = [];
                    series.data.map((year, yearindex) => {
                        monthlyaverages.push({ year: year.info.year, data: [] });
                        for (i = 0; i < 12; i++) {
                            monthlyaverages[yearindex].data.push({ morningsum: 0, morningcount: 0, eveningsum: 0, eveningcount: 0, month: i + 1 });
                        }
                        year.data.map(tempdata => {
                            let monthindex = this.getDate(tempdata.date).getMonth();
                            if (tempdata.morning !== undefined) {
                                monthlyaverages[yearindex].data[monthindex].morningcount++;
                                monthlyaverages[yearindex].data[monthindex].morningsum += tempdata.morning;
                            }
                            if (tempdata.evening !== undefined) {
                                monthlyaverages[yearindex].data[monthindex].eveningcount++;
                                monthlyaverages[yearindex].data[monthindex].eveningsum += tempdata.evening;
                            }
                        })
                    });

                    let monthlytrenddata = [];
                    let monthindex;
                    for (monthindex = 0; monthindex < 12; monthindex++) {
                        monthlytrenddata.push({ month: monthindex + 1, data: [] });
                        let monthlyvalues = monthlyaverages.map((year, index) => {
                            if (year.data[monthindex].eveningcount > 0 || year.data[monthindex].morningcount > 0) {
                                let value = (year.data[monthindex].eveningsum + year.data[monthindex].morningsum) / (year.data[monthindex].eveningcount + year.data[monthindex].morningcount);
                                monthlytrenddata[monthindex].data.push({ year: year.year, month: monthindex + 1, value: value });
                            }
                        })
                    }
                    this.calculatedMonthlytrends = monthlytrenddata;

                    return monthlytrenddata;
                },
                getDailyFilteredMinMax(filteredvalues) {
                    let sums = [];
                    let dayindex;
                    let index;
                    let value;
                    for (dayindex = 0; dayindex < 366; dayindex++) {
                        value = { date: new Date(this.defaultyear, 0, dayindex + 1), total: { min: 999999, max: -999999, mindate: null, maxdate: null }, day: 0, month: 0 };
                        value.month = value.date.getMonth() + 1;
                        value.day = value.date.getDate();
                        sums.push(value);
                    }      
                    for (index = 0; index < sums.length; index++) {
                        let i = 0;
                        while (i < filteredvalues.length) {
                            if (sums[index].date.getDate() == filteredvalues[i].date.getDate() &&
                                sums[index].date.getMonth() == filteredvalues[i].date.getMonth()) {
                                if (!(isNaN(filteredvalues[i].value))) {
                                    if (filteredvalues[i].value > sums[index].total.max) {
                                        sums[index].total.max = filteredvalues[i].value;
                                        sums[index].total.maxdate = filteredvalues[i].date;
                                    }
                                    if (filteredvalues[i].value < sums[index].total.min) {
                                        sums[index].total.min = filteredvalues[i].value;
                                        sums[index].total.mindate = filteredvalues[i].date;
                                    }
                                }
                            }
                            i++;
                        }
                    }
                    return sums;
                },
                calculateDailyAverages(series) {

                    if (this.calculatedDailyAverages.length > 0) return this.calculatedDailyAverages;
                    let sums = [];
                    let dayindex;
                    let yearindex;
                    let index;
                    let value;
                    for (dayindex = 0; dayindex < 366; dayindex++) {
                        value = { date: new Date(this.defaultyear, 0, dayindex + 1), morning: { sum: 0, count: 0, average: NaN, min: 999999, max: -999999, mindate: null, maxdate: null }, evening: { sum: 0, count: 0, average: NaN, min: 999999, max: -999999, mindate: null, maxdate: null }, total: { sum: 0, count: 0, average: NaN, min: 999999, max: -999999, mindate: null, maxdate: null }, day: 0, month: 0 };
                        value.month = value.date.getMonth() + 1;
                        value.day = value.date.getDate();
                        sums.push(value);
                    }
                    let dayreadings;
                    let dt;
                    let month;
                    let day;
                    for (yearindex = 0; yearindex < series.data.length; yearindex++) {
                        for (dayindex = 0; dayindex < series.data[yearindex].data.length; dayindex++) {
                            dayreadings = series.data[yearindex].data[dayindex];
                            dt = new Date(dayreadings.datetimeUtc);
                            month = dt.getMonth() + 1;
                            day = dt.getDate();
                            let foundsum = sums.find(s => s.day == day && s.month == month);
                            if (foundsum) {
                                if (dayreadings.morning !== undefined && this.isNumeric(dayreadings.morning)) {
                                    foundsum.morning.count += 1;
                                    foundsum.morning.sum += dayreadings.morning;
                                    foundsum.total.count += 1;
                                    foundsum.total.sum += dayreadings.morning;
                                    if (dayreadings.morning < foundsum.morning.min) {
                                        foundsum.morning.min = dayreadings.morning;
                                        foundsum.morning.mindate = dayreadings.date;
                                    }
                                    if (dayreadings.morning > foundsum.morning.max) {
                                        foundsum.morning.max = dayreadings.morning;
                                        foundsum.morning.maxdate = dayreadings.date;
                                    }
                                }
                                if (dayreadings.evening !== undefined && this.isNumeric(dayreadings.evening)) {
                                    foundsum.evening.count += 1;
                                    foundsum.evening.sum += dayreadings.evening;
                                    foundsum.total.count += 1;
                                    foundsum.total.sum += dayreadings.evening;
                                    if (dayreadings.evening < foundsum.evening.min) {
                                        foundsum.evening.min = dayreadings.evening;
                                        foundsum.evening.mindate = dayreadings.date;
                                    }
                                    if (dayreadings.evening > foundsum.evening.max) {
                                        foundsum.evening.max = dayreadings.evening;
                                        foundsum.evening.maxdate = dayreadings.date;
                                    }
                                }
                                if (dayreadings.evening !== undefined && this.isNumeric(dayreadings.evening) &&
                                    dayreadings.morning !== undefined && this.isNumeric(dayreadings.morning)) {
                                    let value = (dayreadings.morning + dayreadings.evening) / 2;
                                    if (value < foundsum.total.min) {
                                        foundsum.total.min = value;
                                        foundsum.total.mindate = dayreadings.date;
                                    }
                                    if (value > foundsum.total.max) {
                                        foundsum.total.max = value;
                                        foundsum.total.maxdate = dayreadings.date;
                                    }
                                }                                
                            }
                        }
                    }
                    for (dayindex = 0; dayindex < sums.length; dayindex++) {
                        if (sums[dayindex].morning.count > 0) {
                            sums[dayindex].morning.average = sums[dayindex].morning.sum / sums[dayindex].morning.count;
                        }
                        if (sums[dayindex].evening.count > 0) {
                            sums[dayindex].evening.average = sums[dayindex].evening.sum / sums[dayindex].evening.count;
                        }
                        if (sums[dayindex].total.count > 0) {
                            sums[dayindex].total.average = sums[dayindex].total.sum / sums[dayindex].total.count;
                        }
                    }
                    this.calculatedDailyAverages = sums;
                    return sums;
                },
                getSeasonTrends(series, monthnumbers, monthnames) {
                    let monthlytrenddata = this.calculateMonthlyTrends(series);

                    let datavalues = [];
                    let v = monthlytrenddata.map(month => {
                        if (month.month == monthnumbers[0] || month.month == monthnumbers[1] || month.month == monthnumbers[2]) {
                            let values = [];
                            let t = month.data.map(value => {
                                values.push({ value: [new Date(value.year, 0, 1), this.roundNumber(value.value, 2)], tooltip: `${value.year} ${value.month} ${this.roundNumber(value.value, 2)}` });
                            });
                            datavalues.push({ values: values, location: series.data[0].info.location, year: 0, name: monthnames[datavalues.length] });
                        }
                    });
                    let summertrend = this.calculateTrend([monthlytrenddata[monthnumbers[0] - 1], monthlytrenddata[monthnumbers[1] - 1], monthlytrenddata[monthnumbers[2] - 1]]);
                    let newvalues = [];
                    series.data.map((ser, serieindex) => {
                        newvalues.push({ value: [new Date(ser.info.year, 0, 1), this.roundNumber(ser.info.year * summertrend.k + summertrend.b, 2)], tooltip: `${ser.info.year} Suuntaus ${this.roundNumber(ser.info.year * summertrend.k + summertrend.b, 2)}` });
                    });
                    datavalues.push({ values: newvalues, location: series.data[0].info.location, year: 0, name: `Trendi ${summertrend.k > 0 ? '+' : ''}${this.roundNumber(summertrend.k * 10, 1)}°C/10v` });
                    return datavalues;
                },
                createMonthlySummerTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [6, 7, 8], ['Kesäkuu', 'Heinäkuu', 'Elokuu']);

                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createMonthlyWinterTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [1, 2, 12], ['Tammikuu', 'Helmikuu', 'Joulukuu']);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createMonthlyFallTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [9, 10, 11], ['Syyskuu', 'Lokakuu', 'Marraskuu']);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createMonthlySpringTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [4, 5, 6], ['Huhtikuu', 'Toukokuu', 'Kesäkuu']);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                calculateMonthlyAverages(series) {
                    this.months = series.data.map(yearserie => {
                        let monthtbl = [];
                        let i;
                        for (i = 0; i < 12; i++) monthtbl.push({sum: 0, count: 0});
                        for (i = 0; i < yearserie.data.length; i++) {
                            let month = yearserie.data[i].datetimeLocal.getMonth();
                            if ((!isNaN(yearserie.data[i].morning) && !isNaN(yearserie.data[i].evening))
                                && (yearserie.data[i].morning !== undefined && yearserie.data[i].evening !== undefined)) {
                                monthtbl[month].sum += (yearserie.data[i].morning + yearserie.data[i].evening)/2;
                                monthtbl[month].count++;
                            }
                        }
                        return {
                            year: yearserie.info.year,
                            months: monthtbl.map(m => ({
                                average: m.count == 0 ? NaN : m.sum / m.count,
                            })),
                        }
                    })
                },
                createAllYearsMonthlyAverageSeriedata(series) {
                    let index;
                    let months = [];
                    let dailyvalues = this.createAllYearsAverageSeriedata(series);
                    dailyvalues.data.forEach((yeardata, ind) => {
                        let tempvalue;
                        let month;
                        months.push([]);
                        for (index = 0; index < 12; index++) months[ind].push({ sum: 0, count: 0, average: NaN });
                        yeardata.values.forEach(dailyValues => {
                            month = dailyValues.value[0].getMonth();
                            tempvalue = dailyValues.value[1];
                            if (tempvalue) {
                                months[ind][month].count++;
                                months[ind][month].sum += tempvalue;
                            }
                        })
                        months[ind].forEach(m => { if (m.count > 0) m.average = m.sum / m.count; })
                    })
                    dailyvalues.data.forEach((monthdata, datasetindex) => {
                        let newvalues = [];
                        let y = monthdata.values[0].value[0].getFullYear();
                        let monthindex;
                        for (monthindex = 0; monthindex < months[datasetindex].length; monthindex++) {
                            let newdate = new Date(y, monthindex, 1);
                            newvalues.push({ tooltip: `${monthdata.name}  ${this.roundNumber(months[datasetindex][monthindex].average, 2)}`, value: [newdate, months[datasetindex][monthindex].average] });
                        }
                        monthdata.values = newvalues;
                    })

                    return dailyvalues;
                },
                filterSeries(serie, filterlength) {
                    let lastvalues = [];
                    let filtered = serie.map((ss, i) => {
                        if (!isNaN(ss.value)) {
                            if (lastvalues.length >= filterlength) {
                                lastvalues.splice(0, 1);
                            }
                            lastvalues.push({date: ss.date, value: ss.value});
                            let first = new Date(ss.date.getFullYear(), ss.date.getMonth(), ss.date.getDate() - filterlength / 2);
                            let last = new Date(ss.date.getFullYear(), ss.date.getMonth(), ss.date.getDate() + filterlength / 2);
                            let firstindex = 0;
                            let lastindex = 0;
                            while (firstindex < lastvalues.length && lastvalues[firstindex].date < first) {
                                firstindex++;
                            }
                            while (lastindex < lastvalues.length && lastvalues[lastindex].date < last) {
                                lastindex++;
                            }
                            let index;
                            let sum = 0;
                            for (index = firstindex; index < lastindex; index++) {
                                sum += lastvalues[index].value;
                            }
                            return {value: sum / (lastindex-firstindex), date: ss.date };
                            // const sum = lastvalues.reduce((accumulator, currentValue) => {
                            //     accumulator += currentValue.value;
                            //     return accumulator;
                            // }, 0);
                            // return {value: sum / lastvalues.length, date: ss.date};
                        }
                        return {value: NaN, date: ss.date};
                    })
                    return filtered;
                },
                createLinearContTable(series) {
                    let tbl = [];
                    let year;
                    for (year = series.data[0].info.year; year <= series.data[series.data.length - 1].info.year; year++) {
                        let day;
                        const lastday = year % 4 == 0 ? 366 : 365;
                        for (day = 1; day <= lastday; day++) tbl.push({ value: NaN, average: NaN, date: new Date(year, 0, day) });
                    }
                    let currindex = 0;
                    series.data.forEach((yearserie, i) => {
                        let currdateindex;
                        while (currindex < tbl.length && tbl[currindex].date.getFullYear() < yearserie.info.year) currindex++;
                        if (currindex < tbl.length) {
                            for (currdateindex = 0; currdateindex < yearserie.data.length; currdateindex++) {
                                if (yearserie.info.year === tbl[currindex].date.getFullYear()) {
                                    const t = yearserie.data[currdateindex].datetimeLocal;
                                    while (currindex < tbl.length && tbl[currindex].date < t) currindex++;
                                    if (currindex < tbl.length) {
                                        if (t.getDate() === tbl[currindex].date.getDate()) {
                                            if (yearserie.data[currdateindex].evening !== undefined && yearserie.data[currdateindex].morning !== undefined) {
                                                const value = (yearserie.data[currdateindex].evening + yearserie.data[currdateindex].morning) / 2;
                                                tbl[currindex].value = value;
                                                currindex++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    })
                    return tbl;
                },
                createAllYearsFilteredSeriedata(series) {
                    const filtersize = 10;

                    const tbl = this.createLinearContTable(series);
                    let valuearray = [];
                    const filtered = this.filterSeries(tbl, filtersize);
                    let curryear = 0;
                    filtered.forEach((f, ii) => {
                        if (f.date.getFullYear() != curryear) {
                            curryear = f.date.getFullYear();
                            valuearray.push({year: curryear, name: curryear.toString(), values: [], location: 'kukku'});
                        }
                        let dt = new Date(this.defaultyear, f.date.getMonth(), f.date.getDate());
                        valuearray[valuearray.length-1].values.push({value: [dt, f.value], tooltip: `${this.getDateTxt(f.date)} ${this.roundNumber(f.value,1)}`});
                    })
                    // add minimum and maximum values to screen data
                    let minimum = {};
                    let maximum = {};
                    let minmax = this.getDailyFilteredMinMax(filtered);
                    maximum.values = minmax.map(r => {
                        return {
                            value: [r.date, r.total.max],
                            tooltip: `Maksimi ${this.getDateTxt(r.total.maxdate)} ${this.roundNumber(r.total.max, 1)}`,
                        }
                    });
                    maximum.name = 'Maksimi';
                    minimum.values = minmax.map(r => {
                        return {
                            value: [r.date, r.total.min],
                            tooltip: `Minimi ${this.getDateTxt(r.total.mindate)} ${this.roundNumber(r.total.min, 1) }`,
                        }
                    });
                    minimum.name = 'Minimi';                    

                    valuearray.push(minimum);
                    valuearray.push(maximum);
                    const seriedata = {
                        data: valuearray,
                        params: {showlegend: true, selection: [curryear, 'Minimi','Maksimi'], series: [{ name: 'Minimi', color: '#777777' }, { 'name': 'Maksimi', color: '#777777' }]}
                    };
                    /*
                    let values = [];
                    values.push({value: [datetime, reading], tooltip: ''})

                    let datavalues = [];
                    datavalues.push({values: values, location: '', year: 2000})

                    return {data: datavalues, params: null}
                    */
                    // return values                             
                    return seriedata;
                },
                createAllYearsAverageSeriedata(series) {
                    let dayindex, index;
                    let sums = this.calculateDailyAverages(series);

                    let loc = null;
                    for (index = 0; index < series.data.length; index++) {
                        if (series.data[index].info.location !== loc) {
                            if (loc === null) loc = series.data[index].info.location;
                            else loc = loc + ', ' + series.data[index].info.location;
                        }
                    }
                    if (loc === null) loc = '';

                    let valuearray1 = sums.map(s => ({
                        value: [s.date, s.morning.average],
                        tooltip: `Aamu ${this.getDateTxt(s.date, true)} ${this.roundNumber(s.morning.average, 2)}`,
                    }))
                    let valuearray2 = sums.map(s => ({
                        value: [s.date, s.evening.average],
                        tooltip: `Ilta ${this.getDateTxt(s.date, true)} ${this.roundNumber(s.evening.average, 2)}`,
                    }))
                    let valuearray3 = sums.map(s => ({
                        value: [s.date, s.total.average],
                        tooltip: `Keskiarvo ${this.getDateTxt(s.date, true)} ${this.roundNumber(s.total.average, 2)}`,
                    }))
                    let returnvalues1 = {
                        values: valuearray1,
                        location: loc,
                        year: 0,
                        name: 'Aamu',
                    }
                    let returnvalues2 = {
                        values: valuearray2,
                        location: loc,
                        year: 0,
                        name: 'Ilta',
                    }
                    let returnvalues3 = {
                        values: valuearray3,
                        location: loc,
                        year: 0,
                        name: 'Keskiarvo',
                    }
                    const seriedata = {
                        data: [returnvalues1, returnvalues2, returnvalues3],
                        params: null
                    };
                    return seriedata;
                },
                getSelection(seriedata, selectedseries) {
                    let selection = {};
                    seriedata.data.forEach(s => {
                        selection[s.name] = false;
                    })
                    if (selectedseries && selectedseries.length) {
                        selectedseries.forEach(s => {
                            selection[s] = true;
                        })
                    }
                    return selection;
                },

                //initSerieLegends(data) {
                // let selection = [];
                // if (activation.playernumbers && activation.playernumbers.length) {
                //     activation.playernumbers.forEach((pno, i) => {
                //         let foundplayer = data.options.chartitems.find((item, index) => {
                //             let matchplayer = item.name.match(/^(\d{1,2}) ./);
                //             return (matchplayer && pno == Number(matchplayer[1]));
                //         });
                //         if (foundplayer) selection.push(foundplayer.name);
                //     });
                // }
                // else if (activation.names && activation.names.length) {
                //     return activation.names;
                // }
                //return selection;
                //},

            }
        }).mount('#app');

    </script>

</body>

</html>