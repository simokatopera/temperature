<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilat (2)</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "//unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <script src="chartfunctions.js" defer></script>

    <style>

        .graphelement {
            width: 1100px;
            height: 380px;
        }
        .datatable,
        .datatable th,
        .datatable td {
            border: 1px solid;
            text-align: center;
        }
        .latestreadingtable,
        .latestreadingtable th,
        .latestreadingtable td  {
            border: 1px solid;
            text-align: center;
        }
        .active {
            background-color: lightgreen;
        }
        .morninghigh {
            background-color: rgb(245, 113, 113);
        }
        .morninglow {
            background-color: rgb(174, 139, 255);
        }
        .eveninghigh {
            background-color: rgb(245, 113, 113);
        }
        .eveninglow {
            background-color: rgb(174, 139, 255);
        }
        .actionbutton {
            background-color: lightblue;
        }
        .actionbutton.active {
            background-color: red;
        }
        .setmargin5 {
            margin: 5px;
        }
        #daygraph {
            display: inline-block;
            width: 400px;
            height: 380px;
        }
        .scrollbox {
            height: 400px;
            width: 520px;
            overflow: scroll;
        }
        .hidden {
            display: none;
        }
        .graphtitle {
            font-size: 20px;
            font-weight: bold;
        }
        .loader {
            border: 5px solid #f3f3f3;
            /* Light grey */
            border-top: 5px solid #3498db;
            /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
        }        
        @media screen and (max-width: 1080px) {
            .scrollbox {
                height: 420px;
                width: 420px;
                overflow: scroll;
            }            
        } 
        @media screen and (max-width: 800px) {
            .hideifnarrow {display:none}
            .scrollbox {
                height: 400px;
                width: 280px;
                overflow: scroll;
            }        
        }        
    
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilat</h1>
        </div>
        <div id="app" class="page-content">
            <div :style="loading?'display:none;':'display:inline-block;'">
                <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#loadModal">Näytä viimeiset</button>
            </div>

            <div id="loader1" class="loader hidden"></div>            
            <hr>
            <div class="row">
                <div class="col-6" :style="loading?'display:none;':'display:inline-block;'">
                    <readings :temperatures="readings" :selectedday="selectedday" @dayselected="dayselected"></readings>
                    <div id="loader2" class="loader hidden"></div>
                <!-- <button v-for="item in readings.years" @click="showselectedyear(item)">{{ item.year }}</button> -->
                </div>
                <div class="col-6" :style="!loading && daydata.data[0].length>0?'display:inline-block;':'display:none;'">
                    <div class="dayscroll hidden">
                    <button type="button" :disabled="this.scrollday.scroll" class="btn btn-primary setmargin5" @click="rundays">Rullaa</button>
                    <button type="button" :disabled="!this.scrollday.scroll" class="btn btn-primary setmargin5" @click="stopdays">Pysäytä</button>
                    <hr>
                    <p class="graphtitle">{{ dailycharttitle }}</p>
                    <div id="daygraph"></div>
                    </div>
                </div>
            </div>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph10" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph4" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph12" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph2" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles":title="''" :elemid="testgraph3" :active=true></trendgraph>
            <monthtable :title="'Kuukausittaiset lämpötilat'" :monthlydata="calculated.monthlyaverages.yearlyvalues" :monthaverages="calculated.monthlyaverages.monthlyaverages.temperature" :monthnames="monthnames" :datatype="'t'"></monthtable>
            <monthtable :title="'Kuukausittaiset lämpötilaerot'":monthlydata="calculated.monthlyaverages.yearlyvalues" :monthaverages="calculated.monthlyaverages.monthlyaverages.diff" :monthnames="monthnames" :datatype="'d'"></monthtable>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph11" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph5" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph6" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph7" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph8" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph9" :active=true></trendgraph>

<!-- Latest readings modal start---------------------------------------------------------- -->
            <div id="loadModal" class="modal fade" tabindex="-1" aria-labelledby="modifyAccessLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="modifyAccessLabel">Viimeisimmät lukemat</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <table class="latestreadingtable">
                                <tr>
                                    <th>Päivä</th><th>Aamu</th><th>Ilta</th><th>Aamu</th><th>Ilta</th>
                                </tr>
                            <tr v-for="item in latestReadings">
                                <td>{{item.observation.morningtime.getDate() }}.{{item.observation.morningtime.getMonth()+1 }}.{{item.observation.morningtime.getFullYear()}}</td>
                                <td>{{ isNaN(item.observation.morning) ? '' : item.observation.morning }}</td>
                                <td>{{ isNaN(item.observation.evening) ? '' : item.observation.evening }}</td>
                                <td>{{ isNaN(item.reading.morning) ? '' : item.reading.morning }}</td>
                                <td>{{ isNaN(item.reading.evening) ? '' : item.reading.evening }}</td>
                            </tr>
                            </table>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-success">Tallenna</button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Sulje</button>
                        </div>
                    </div>
                </div>
            </div>
<!-- Latest readings modal end----------------------------------------------------------- -->

        </div>
    </div>
    <script type="module">

        import { createApp, ref } from 'vue'

        let Galltemperaturereadings = { values: [], years: [], filtersize: 7 }
        let Gcharts = [];

        function selectFirstDay() {
            let button = document.getElementsByClassName('daybutton_0');
            if (button && button.length) button[0].click();
            else setTimeout(() => { selectFirstDay(); }, 50);
        }
        (async function () {
            setTimeout(() => { selectFirstDay(); }, 50);
        })();

        const vueapp = createApp({
            data() {
                return {
                    readings: { values: [], years: [], filtersize: 0 },

                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    testgraph9: 'GraphLocation9',
                    testgraph10: 'GraphLocation10',
                    testgraph11: 'GraphLocation11',
                    testgraph12: 'GraphLocation12',
                    testgraphtitles : [],
                    dailycharttitle: '',
                    defaultyear: 1976,
                    loading: ref(true),
                    daydata: {data: [[],[]], chart: null},
                    latestReadings: [],
                    scrollday: {
                        firstdate: null,
                        selecteddate: null,
                        selecteddayindex: -1,
                        scroll: false,
                    },
                    selectedday: 0,
                    monthnames: ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'],
                    monthnamesLong: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
                    calculated : {
                        monthlytrends: [],
                        monthlyaverages: {yearlyvalues: [], calculated: [], monthlyaverages: []},
                    },
                }
            },
            async mounted() {

                this.startSpinner(1);
                let years = await apiGetYears('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', 'Salo');
                //years.data = [2021,2022,2023,2024]
                let temperatures = await apiGetTemperatures('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', "Salo", years.data);
                this.checkData(temperatures);

                const stationreadings = await apiGetLatestTemperatures();
                this.latestReadings = compareReadings(temperatures, stationreadings);

                CFinitTemperature(temperatures, Galltemperaturereadings.filtersize, this.monthnames, this.monthnamesLong);

                Galltemperaturereadings = CFgetAllReadings();

                this.readings.filtersize = Galltemperaturereadings.filtersize;
                this.readings.values = [];
                const temp = Galltemperaturereadings.values.map((v, i) => ({year: v.date.getFullYear(), index: i}));
                let prev = '';
                this.readings.years = temp.filter(v => { let returnvalue = v.year != prev; prev = v.year; return returnvalue;});
                this.fillTemperaturereadingtable(0, this.readings.values, Galltemperaturereadings.values[0].date.getFullYear(), this.stoploading);

                this.calculated.monthlyaverages = CFcalculateMonthlyAverages();

                this.createChart(this.testgraph10, 'Suodatetut lämpötilat', temperatures, CFcreateYearlyFilteredSeriedata);
                this.createChart(this.testgraph2, 'Päivittäiset keskiarvot', temperatures, CFcreateAllYearsAverageSeriedata);
                this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', temperatures, CFcreateAllYearsMonthlyAverageSeriedata);
                this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', temperatures, CFcreateAllYearsFilteredSeriedata);
                this.createChart(this.testgraph4, 'Viimeinen vuosi', temperatures, CFcreateLastYearsSeriedata);
                this.createChart(this.testgraph9, 'Aamun ja illan ero (suodatettu)', temperatures, CFcreateDailyDiffdata);
                this.createChart(this.testgraph12, 'Korkeimmat ja matalimmat arvot/vuosi (kpl)', temperatures, CFcreateYearlyHighValuedata);
                this.createChart(this.testgraph11, 'Vuosittainen suuntaus', temperatures, CFcreateYearlyTrendSeriedata);

                Gcharts.push(this.createChart(this.testgraph5, 'Kesän suuntaus', temperatures, CFcreateMonthlySummerTrendSeriedata));
                Gcharts[Gcharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                Gcharts.push(this.createChart(this.testgraph6, 'Talven suuntaus', temperatures, CFcreateMonthlyWinterTrendSeriedata));
                Gcharts[Gcharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                Gcharts.push(this.createChart(this.testgraph7, 'Syksyn suuntaus', temperatures, CFcreateMonthlyFallTrendSeriedata));
                Gcharts[Gcharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                Gcharts.push(this.createChart(this.testgraph8, 'Kevään suuntaus', temperatures, CFcreateMonthlySpringTrendSeriedata));
                Gcharts[Gcharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                let item = document.getElementsByClassName("dayscroll hidden");
                if (item && item.length) item[0].classList.remove("hidden");
                this.stopSpinner();
            },
            updated() {
                //this.stoploading();
                // let button = document.getElementsByClassName('daybutton_0');
                // if (button && button.length) button[0].click();
            },
            components: {
                readings: {
                    props: ['temperatures', 'selectedday'],
                    emits: ['dayselected'],
                    data: function () {
                        return {
                            selected: ref(-1),
                            sum: ref(0),
                            arrowup: String.fromCharCode(0x2191),
                            arrowdn: String.fromCharCode(0x2193),
                        }
                    },
                    computed: {
                        calculateAverage: function () {
                            this.sum = 0;
                        }
                    },
                    methods: {
                        setSum(value) {
                            this.sum = value;
                        },
                        roundNumber(value, num) {
                            return roundNumber(value, num)
                        },
                        calcSums() {
                            let setvalue = this.setSum;
                            setTimeout(function () {
                                let elements = document.getElementsByClassName('xxx active');
                                if (elements.length == 0) {
                                    setvalue(0);
                                    return;
                                }
                                let index;
                                let sum = 0;
                                let count = 0;
                                for (index = 0; index < elements.length; index++) {
                                    if (isNumeric(elements[index].innerText)) {
                                        sum += Number(elements[index].innerText);
                                        count++;
                                    }
                                }
                                if (count > 0) setvalue(sum / count);
                                else setvalue(-1);
                            }, 1)
                        },
                        getDateTxt(date) {
                            return getDateTxt(date);
                        },
                        selectDay(item) {
                            if (this.selected == item.index) this.selected = -1;
                            else this.selected = item.index;
                            this.calcSums();
                            if (this.selected == item.index) {
                                const selectedday = this.temperatures.values[this.selected].date.getDate();
                                const selectedmonth = this.temperatures.values[this.selected].date.getMonth();
                                let values = Galltemperaturereadings.values.map(r => {
                                    if (r && r.date && r.date.getDate() == selectedday && r.date.getMonth() == selectedmonth) {
                                        return {date: r.date, value: r.average, morning: r.morning, evening: r.evening, datetimeLocal: r.date}
                                    }
                                    else return null
                                })
                                this.$emit('dayselected', {values: values.filter(v => v !== null), selected: this.selected});
                            }
                            else this.$emit('dayselected', {values: [], selected: -1});
                        },
                        markIfPressed(item) {
                            if (this.selected < 0) return { active: false };
                            if (this.selected == item.index) return { active: true }
                            return { active: false };
                        },
                        getClass(index) {
                            return `daybutton_${index}`;
                        },
                        markIfSelected(item, mode) {
                            if (this.selected < 0) return { active: false, 
                                morninghigh: (mode == 1 && item.morninghighest), morninglow: (mode == 1 && item.morninglowest),
                                eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest) };

                            if (item.date >= this.temperatures.values[this.selected].firstdayfilter &&
                                item.date < this.temperatures.values[this.selected].lastdayfilter) {
                                return { active: true, 
                                    morninghigh: mode == 1 && item.morninghighest, morninglow: mode == 1 && item.morninglowest,
                                    eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest) 
                                };
                                
                            }
                            return { active: false, 
                                    morninghigh: mode == 1 && item.morninghighest, morninglow: mode == 1 && item.morninglowest,
                                    eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest)  }
                        },
                        saveValuestoFile() {
                            let data = Galltemperaturereadings.values.map(line => (
                                `${this.getDateTxt(line.date)}\t${roundNumber(line.morning, 1)}\t${roundNumber(line.evening, 1)}\t${roundNumber(line.averagefiltered, 1)}`
                            ));
                            let filename = 'readings.txt';
                            this.saveToFile(`Päivämäärä\tAamu\tIlta\tSuodatettu(${Galltemperaturereadings.filtersize})\n${data.join('\n')}`, filename, `Tallennettu tiedostoon ${filename}`, '');
                        },
                        saveToFile(dataToSave, fileName, successmsg, eventname) {
                            var gameblob = new Blob([dataToSave], { type: 'text/plain' })
                            if (this.objUrl !== null) window.URL.revokeObjectURL(this.objUrl);
                            this.objUrl = (window.webkitURL || window.URL).createObjectURL(gameblob);
                            var anchor = document.createElement('a');
                            anchor.download = fileName;
                            anchor.href = this.objUrl;
                            anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
                            anchor.click();
                            // document.querySelector("body").dispatchEvent(
                            //     new CustomEvent(eventname, {
                            //         bubbles: true,
                            //         detail: { text: () => successmsg },
                            //     })
                            // );
                        },

                    },
                    template: `
                        <p class="graphtitle">Mittaustulokset ja suodatettu arvo</p>
                        <div><button type="button" class="btn btn-primary" @click="saveValuestoFile">Tallenna kaikki lukemat tiedostoon</button></div>
                        <div class="scrollbox">
                        <table class="datatable">
                            <thead><tr><td></td><td>Aamu</td><td>Ilta</td><td>Suod({{temperatures.filtersize}})</td><td class="hideifnarrow">Alkupvm</td><td class="hideifnarrow">Loppupvm</td></tr></thead>
                            <tbody>
                                <tr v-for="(item, index) in temperatures.values">
                                    <td :class="markIfPressed(item)" align="center"> 
                                        <button class="actionbutton" @click="selectDay(item)" :class="markIfPressed(item),getClass(index)">
                                            {{ getDateTxt(item.date) }} 
                                        </button> 
                                    </td>
                                    <td class="xxx" :class="markIfSelected(item, 1)"> {{ roundNumber(item.morning, 1) }}{{ item.morninghighest ? this.arrowup : "" }}{{ item.morninglowest ? this.arrowdn : "" }}</td>
                                    <td class="xxx" :class="markIfSelected(item, 2)"> {{ roundNumber(item.evening, 1) }}{{ item.eveninghighest ? this.arrowup : "" }}{{ item.eveninglowest ? this.arrowdn : "" }} </td>
                                    <td :class="markIfPressed(item)"> {{ roundNumber(item.averagefiltered, 1) }} </td>
                                    <td class="hideifnarrow"> {{ getDateTxt(item.firstdayfilter) }} </td>
                                    <td class="hideifnarrow"> {{ getDateTxt(item.lastdayfilter) }} </td>
                                </tr>                                
                            </tbody>
                        </table>            
                        </div>            
                        `
                },
                monthtable: {
                    props: ['monthlydata', 'monthnames', 'monthaverages', 'title', 'datatype'],
                    emits: ['lastyear'],
                    methods: {
                        roundNumber(value, num) {
                            return roundNumber(value, num);
                        },
                        getTableTemperatureValue(m) {
                            if (isNaN(m.temperature)) return '-'
                            return `${m.estimate ? '(' : ''}${roundNumber(m.temperature, 1)}${m.estimate ? ')' : ''}`;
                        },
                        getTableDifferenceValue(m) {
                            if (isNaN(m.difference)) return '-'
                            return `${m.estimate ? '(' : ''}${roundNumber(m.difference, 1)}${m.estimate ? ')' : ''}`;
                        },
                    },
                    template: `
                        <hr>
                        <p class="graphtitle">{{ title }}</p>
                        <table class="datatable">
                            <thead>
                                <tr>
                                    <th></th><th v-for="month in monthnames">{{ month }}</th>
                                    <th>Koko vuosi</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in monthlydata">
                                    <td>{{ item.year }}</td> 
                                    <td v-for="m in item.months">{{ datatype=="t" ? getTableTemperatureValue(m) : getTableDifferenceValue(m) }}</td>
                                    <td>{{ item.estimate===true ? '(': ''}}{{ datatype=="t" ? roundNumber(item.yearaverage, 1): roundNumber(item.yearaveragediff, 1) }}{{ item.estimate==true?')':''}}</td>
                                </tr>                                
                            </tbody>
                            <tfoot>
                                <tr>
                                    <th>Yht</th>
                                    <th v-for="value in monthaverages">{{ roundNumber(value,1) }}</th>
                                </tr>
                            </tfoot>
                        </table>
                        `
                },
                trendgraph: {
                    props: ['title', 'elemid', 'active', 'titles'],
                    template: `
                        <hr>
                        <div>
                            <p class="graphtitle">{{ titles[elemid] ? titles[elemid] : '' }}</p>
                            <div :class="{hidden: !active}" class="trendchart">
                                <div class="trendtitle"></div>
                                <div :id="elemid" class="graphelement"></div>
                            </div>
                        </div>
                        `
                }
            },
            methods: {
                stoploading() {
                    this.loading = false;
                },
                startSpinner(no) {
                    const elem = document.getElementById(`loader${no}`);
                    if (elem) elem.classList.remove('hidden');
                },
                stopSpinner() {
                    const elems = document.getElementsByClassName('loader')
                    if (elems) {
                        let i = 0;
                        for (i = 0; i < elems.length; i++) elems[i].classList.add('hidden');
                    }
                },     
                showselectedyear(item) {
                    this.dayselected({selected: -1, values: []});
                    this.startSpinner(2);
                    this.readings.values = [];
                    setTimeout( () => {this.fillTemperaturereadingtable(item.index, this.readings.values, Galltemperaturereadings.values[item.index].date.getFullYear(), this.stopSpinner)}, 10);
                },
                fillTemperaturereadingtable(index, desttable, year, stopFunc) {
                    const maxyears = 2;
                    let i;
                    for (i = index; i < Galltemperaturereadings.values.length && i < index + 1000 && Galltemperaturereadings.values[i].date.getFullYear() > year-maxyears;i++) 
                        desttable.push(Galltemperaturereadings.values[i]);
                    if (i < Galltemperaturereadings.values.length && Galltemperaturereadings.values[i].date.getFullYear() > year-maxyears) setTimeout(fillTemperaturereadingtable, 200, i, desttable, year);
                    else stopFunc();
                },
                monthlytrendcallback(params) {
                    const seriestatus = Object.keys(params.selected).map(k => ({status: params.selected[k], name: k}));
                    let i = 0;
                    let j;
                    let chart = null;
                    while (!chart && i < Gcharts.length) {
                        j = 0;
                        while (j < Gcharts[i].serieOptions.series.length && !chart) {
                            // only one serie cheked, maybe should be more
                            let search = seriestatus.find(s => Gcharts[i].serieOptions.series[j].trend == false && Gcharts[i].serieOptions.series[j].name == s.name);
                            if (search) chart = Gcharts[i];
                            else j++;
                        }
                        if (!chart) i++;
                    }
                    if (!chart) return;

                    const series = chart.serieOptions.series.map(d => {
                        let search = seriestatus.find(s => s.name == d.name);
                        if (!d.trend && search && search.status === true) {
                            // serie active
                            return {
                                name: d.name,
                                num: d.num,
                                data: d.data.map(val => ({
                                    value: isNumeric(val.value[1]) ? Number(val.value[1]) : NaN,
                                    year:  val.value[0].getFullYear(),
                                }))
                            }
                        }
                        return null;
                    }).filter(v => v !== null);

                    const originaltrendserie = chart.serieOptions.series.find(d => d.trend == true);
                    if (!originaltrendserie) return;
                    const tempserie = {data: chart.serieOptions.series[0].data.map(ss => ({info: {year: ss.value[0].getFullYear(), location: ''}}))};
                    const temp = createTrendForGivenMonths(series.map(s => s.num), series.map(s => s.name));
                    const datavalues = temp.values;
                    const newtrendserie = datavalues.find(d => d.trend == true);
                    if (!newtrendserie) return;
                    originaltrendserie.data = newtrendserie.values.map(v => v);
                    originaltrendserie.name = newtrendserie.name;
                    chart.trendChart.setOption(chart.serieOptions);
                },                
                checkData(temperatures) {
                    temperatures.data.forEach(t => {
                        const year = t.info.year;
                        let prevdate = 0;
                        t.data.forEach(d => {
                            if (d.datetimeLocal.getFullYear() !== year) {
                                alert(`Invalid year ${d.date.getFullYear()}`);
                            }
                            if (prevdate >= d.datetimeLocal) {
                                alert(`Invalid date ${d.datetimeLocal.getDate(0)}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`);
                            }
                            prevdate = d.datetimeLocal;
                        })
                    })
                },
                //------------------------------------------------------------------------------
                createChart(element, title, data, funct, thischart) {
                    this.testgraphtitles[element] = title;
                    let trendChart = (thischart ? thischart.trendChart : this.initSerie(element));
                    if (trendChart === null) return;
                    const buildValues = funct(data);
                    const params = buildValues.params;
                    let serieOptions = this.buildChartOptions(title, buildValues);

                    trendChart.setOption(serieOptions);
                    return {trendChart, serieOptions, params};
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                getMinMaxValue(series) {
                    let min = getTempMinDefaultValue();
                    let max = getTempMaxDefaultValue();
                    series.data.forEach(s => {
                        s.values.forEach(point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return { min: min, max: max }
                },
                getSelection(seriedata, selectedseries) {
                    let selection = {};
                    seriedata.data.forEach(s => {
                        selection[s.name] = false;
                    })
                    if (selectedseries && selectedseries.length) {
                        selectedseries.forEach(s => {
                            selection[s] = true;
                        })
                    }
                    return selection;
                },                
                buildChartOptions(title, series) {
                    const monthnames = this.monthnames;
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: '',//title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function (value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (series.params && series.params.legend && series.params.legend.items) {
                                        return series.params.legend.items[m];
                                    }
                                    if (y < 1978) return monthnames[m];
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series, series.params),
                        legend: {
                            show: false,
                            textStyle: { color: '#f0f', fontSize: '16' },
                        },
                    };
                    if (series.params) {
                        if (series.params.rangeoffset) {
                            let minmax = this.getMinMaxValue(series);
                            let offset = Number(series.params.rangeoffset);
                            chartoptions.yAxis.min = roundNumber(minmax.min - offset - 1, 0);
                            chartoptions.yAxis.max = roundNumber(minmax.max + offset, 0);
                        }
                        if (series.params.showlegend) {
                            chartoptions.legend.show = true;
                        }
                        if (series.params.selection) {
                            chartoptions.legend.selected = this.getSelection(series, series.params.selection);
                        }
                    }

                    return chartoptions;
                },
                //------------------------------------------------------------------------------
                dayselected(data) {
                    this.selectedday = data.selected;
                    // create trend curve
                    if (data.selected >= 0) {
                        this.scrollday.selecteddate = this.scrollday.firstdate = null;
                        this.scrollday.selecteddayindex = data.selected;
                        this.scrollday.scroll = false;
                    }
                    const values = {
                        data: data.values.map(d => ({
                            value: d.value,
                            year: d.date.getFullYear(),
                            date: d.date,
                        }))
                    }
                    const factors = CFcalculateTrend([values]);
                    let trend = data.values.map(d => ({
                        value: d.date.getFullYear() * factors.k + factors.b,
                        date: d.date,
                    }))
                    let series = [data.values, trend];
                    this.daydata.data = series;
                    this.dailycharttitle = `Päivän ${values.data.length ? values.data[0].date.getDate() : ''}.${values.data.length ? values.data[0].date.getMonth()+1 : ''} vuosittaisarvot (${factors.k > 0 ? '+' : ''}${roundNumber(factors.k * 10, 1)}°C/10v)`;
                    this.daydata.chart = this.createChart('daygraph', 
                        this.dailycharttitle, 
                        series, this.createDayGraph, this.daydata.chart);
                },
                rundays() {
                    this.scrollday.scroll = true;
                    this.scrollday.firstdate = this.scrollday.selecteddate = this.readings.values[this.scrollday.selecteddayindex].date;
                    setTimeout(this.scrolldayfunction, 1);
                },
                stopdays() {
                    this.scrollday.scroll = false;
                    this.scrollday.selecteddate = this.scrollday.firstdate = null;
                },
                scrolldayfunction() {
                    if (this.scrollday.selecteddate === null) return;

                    let newday = new Date(this.scrollday.selecteddate.getFullYear(), this.scrollday.selecteddate.getMonth(), this.scrollday.selecteddate.getDate() - 1);
                    if (newday <= new Date(this.scrollday.firstdate.getFullYear() - 1, this.scrollday.firstdate.getMonth(), this.scrollday.firstdate.getDate())) {
                        this.scrollday.selecteddate =  this.scrollday.firstdate;
                    }
                    else this.scrollday.selecteddate = newday;

                    const selectedday = this.scrollday.selecteddate.getDate();
                    const selectedmonth = this.scrollday.selecteddate.getMonth();
                    let values = Galltemperaturereadings.values.map(r => {
                        if (r && r.date && r.date.getDate() == selectedday && r.date.getMonth() == selectedmonth) {
                            return {datetimeLocal: r.date, date: r.date, value: r.average, morning: r.morning, evening: r.evening}
                        }
                        else return null
                    }).filter(v => v !== null);

                    this.dayselected({values: values, selected: -1});
                    setTimeout(this.scrolldayfunction, 200);
                },
                getDate(date) {
                    let parts = date.split('/');
                    if (parts && parts.length === 3) return new Date(parts[2], Number(parts[0]) - 1, parts[1]);
                    return NaN;
                },
                getDateTxt(date, daymonth) {
                    return getDateTxt(date, daymonth == true ? true : false);
                },
                createSeries(series, params) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 4,
                        symbol: 'circle',
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                        trend: values.trend,
                        num: values.index,
                    }))

                    if (params) {
                        if (params.series) {
                            params.series.forEach(p => {
                                if (p.name == '') {
                                    // apply to all series
                                    if (p.markersize !== undefined) {
                                        chartdata.forEach(chart => {
                                            chart.symbolSize = p.markersize;
                                        })
                                    }
                                }
                            })
                            chartdata.forEach(d => {
                                let found = params.series.filter(p => p.name === d.name);
                                if (found && found.length) {
                                    d.symbolsize = 1;
                                    if (found.color) d.lineStyle = { color: found.color }

                                    if (found.symbolindex == 'last') {
                                        if (d.data.length) {
                                            d.data[d.data.length-1].symbol = found.symbol;
                                            d.data[d.data.length-1].symbolSize = found.symbolsize;
                                        }
                                    }
                                    else {
                                        let i = 0;
                                        while (i < found.length) {
                                            if (d.data[found[i].symbolindex]) {
                                                if (found[i].symbol) d.data[found[i].symbolindex].symbol = found[i].symbol;
                                            }
                                            if (d.data[found[i].symbolindex]) {
                                                if (found[i].symbolsize) d.data[found[i].symbolindex].symbolSize = found[i].symbolsize;
                                            }
                                            i++;
                                        }
                                    }
                                }
                            })
                        }
                    }
                    return chartdata;
                },
                createDayGraph() {
                    let datavalues = [];
                    this.daydata.data.forEach((serie, i) => {
                        let values = serie.map(dd => (
                            {value: [dd.date, dd.value], tooltip: `Päivä: ${this.getDateTxt(dd.date, false)} ${roundNumber(dd.value, 1)}`}
                        ))
                        datavalues.push({values: values, location: '', year: 0});
                    });
                    return {data: datavalues, params: null}
                },
                //-end of methods-----------------------------------------------------------------------------
            }
        }).mount('#app');

    </script>

</body>

</html>