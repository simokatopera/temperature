<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilat</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <style>
       .graphelement {
            width: 1200px;
            height: 380px;
        }         
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilakäyrät</h1>
        </div>
        <div id="app" class="page-content">
            <trendgraph :active="false" :elemid="testgraph5" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph6" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph7" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph8" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph2" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph3" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph4" :title="trendtitles"></trendgraph>
        </div>
    </div>
    <script type="module">

        import { createApp, ref } from 'vue'

        (async function () {


        })();



        const vueapp = createApp({
            data() {
                return {
                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    trendtitles: [],
                    calculatedMonthlytrends: [],
                    rangemin: -99999999999,
                    rangemax: 9999999999,
                    rangefit: 9999999998,
                }
            },
            async mounted() {
                let years = await apiGetYears('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', 'Salo');
                let temperatures = await apiGetTemperatures('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', "Salo", years.data);

                this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', temperatures, this.createAllYearsMonthlyAverageSeriedata);
                this.createChart(this.testgraph2, 'Päivittäinen keskiarvo', temperatures, this.createAllYearsAverageSeriedata);
                this.createChart(this.testgraph3, 'Päivittäinen keskialämpötilarvo', temperatures, this.createAllYearsSeriedata);
                this.createChart(this.testgraph4, 'Viimeinen vuosi', temperatures, this.createLastYearsSeriedata);
                this.createChart(this.testgraph5, 'Kesän suuntaus', temperatures, this.createMonthlySummerTrendSeriedata);
                this.createChart(this.testgraph6, 'Talven suuntaus', temperatures, this.createMonthlyWinterTrendSeriedata);
                this.createChart(this.testgraph7, 'Syksyn suuntaus', temperatures, this.createMonthlyFallTrendSeriedata);
                this.createChart(this.testgraph8, 'Kevään suuntaus', temperatures, this.createMonthlySpringTrendSeriedata);
            },
            components: {
                'trendgraph': {
                    props: ['active', 'elemid', 'title'],
                    template: `
                        <div :class="{hidden: !active}" class="trendchart">
                            <div class="trendtitle"></div>
                            <div :id="elemid" class="graphelement"></div>
                        </div>
                        `
                }
            },            
            methods: {
                createChart(element, title, temperatures, funct) {
                    let trendChart = this.initSerie(element);
                    if (trendChart === null) return;
                    let serieoptions = this.buildChartOptions(title, funct(temperatures));
                    trendChart.setOption(serieoptions);
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                //setSerie(id, data, chartdata) {
                    //let serie = this.serieinfo.find((s) => s.id == id);
                    //if (!serie) this.serieinfo.push({ id: id, data: data, chartdata: chartdata });
                //},
                getMinMaxValue(series) {
                    let min = 999999999;
                    let max = -999999999;
                    series.data.forEach(s => {
                        s.values.forEach( point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return {min: min, max: max}
                },
                buildChartOptions(title, series) {
                    const months = ['Tammi','Helmi','Maalis','Huhti','Touko','Kesä','Heinä','Elo','Syys','Loka','Marras','Joulu']
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function(value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (y < 1978) return months[m];
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series),
                        legend: {
                            show: false,
                           // data: ['1','2','3']
                        //     data: series.data.map(s => s.year),
                        // //     selected: this.getSelection(temperatures),
                        // //     inactiveColor: '#aaa',
                        //     textStyle: { color: '#f0f', fontSize: '16' },
                        //     type: 'scroll',
                        //     //orient: 'vertical',
                        //     //top: 0,
                        //     //right: 20,
                        },
                    };
                    if (series.params) {
                        if (series.params.range) {
                            if (series.params.range === this.rangefit) {
                                let minmax = this.getMinMaxValue(series);
                                let offset = 0;
                                if (series.params.offset) {
                                    offset = Number(series.params.offset);
                                }
                                chartoptions.yAxis.min = this.roundNumber(minmax.min - offset - 1, 0);
                                chartoptions.yAxis.max = this.roundNumber(minmax.max + offset, 0);
                            }
                            if (series.params.showlegend) {
                                chartoptions.legend.show = true;
                            }
                        }
                    }
                    return chartoptions;
                },
                getDate(date) {
                    let parts = date.split('/');
                    if (parts && parts.length === 3) {
                        return new Date(parts[2], Number(parts[0])-1, parts[1]);
                     }
                    return NaN;
                },
                getDateTxt(date, daymonth) {
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    if (daymonth) return `${day}.${month}`;
                    return `${day}.${month}.${year}`;
                },
                createSeries(series) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 1,
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                    }))                    
                    return chartdata;
                },
                getReadingsBetween(startdate, enddate, series) {
                    if (startdate >= enddate) return [];

                    const startyear = startdate.getFullYear();
                    const endyear = enddate.getFullYear();

                    let startyearindex = 0;
                    while (series.data[startyearindex].info.year < startyear) startyearindex++;
                    let endyearindex = startyearindex;
                    while (series.data[endyearindex].info.year < endyear) endyearindex++;

                    let startdayindex = 0;
                    while (this.getDate(series.data[startyearindex].data[startdayindex].date) < startdate) startdayindex++;
                    let enddayindex = 0;
                    while (this.getDate(series.data[endyearindex].data[enddayindex].date) < enddate) enddayindex++;
                    let yearindex;
                    let dayindex ;
                    let firstindex = startdayindex;
                    let readings = [];
                    for (yearindex = startyearindex; yearindex <= endyearindex; yearindex++) {
                        for (dayindex = firstindex; startyearindex === endyearindex ? dayindex < enddayindex : dayindex < series.data[yearindex].data.length; dayindex++) {
                            readings.push(series.data[yearindex].data[dayindex]);
                        }
                        firstindex = 0;
                    }
                    return readings;
                },
                createLastYearsSeriedata(series) {
                    const seriedata = { 
                        data: null,
                        params: null
                    };
                    if (!series || !series.data || series.data.length == 0) {
                        return seriedata;
                    }
                    const lastdate = this.getDate(series.data[series.data.length-1].data[series.data[series.data.length-1].data.length-1].date);
                    const firstdate = new Date(lastdate.getFullYear() - 1, lastdate.getMonth(), lastdate.getDate());
                    const readings = this.getReadingsBetween(firstdate, lastdate, series);

                    let values1 = readings.map(r => ({
                        value: [this.getDate( r.date), r.morning],
                        tooltip: `Aamu ${this.getDateTxt(this.getDate( r.date))} ${r.morning}`,
                    }));
                    let morning = {};
                    let evening = {};
                    morning.location = series.data[0].info.location;
                    morning.year = firstdate.getFullYear();
                    morning.values = values1;
                    let values2 = readings.map(r => ({
                        value: [this.getDate( r.date), r.evening],
                        tooltip: `Ilta ${this.getDateTxt(this.getDate( r.date))} ${r.morning}`,
                    }));
                    evening.location = morning.location;
                    evening.year = lastdate.getFullYear();
                    evening.values = values2;
                    seriedata.data = [morning, evening];
                    return seriedata;
                },

                createAllYearsSeriedata(series) {
                    let returnvalues = series.data.map(yearserie => ({
                        values: yearserie.data.map(s => ({
                            value: [this.getDate( s.date), s.morning],
                            tooltip: `${yearserie.info.location} ${this.getDateTxt(this.getDate( s.date))} ${s.morning}`,
                        })),
                        location: yearserie.info.location,
                        year: yearserie.info.year,
                    }))
                    const seriedata = { 
                        data: returnvalues,
                        params: null
                    };
                    return seriedata;
                },
                isNumeric(obj){
                    return !Array.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
                },
                roundNumber(value, num) {
                    return value.toFixed(num);
                },
                calculateTrend(valuearray) {
                    let k = 0;
                    let b = 0;
                    let sumxy = 0;
                    let sumx = 0;
                    let sumy = 0;
                    let sumxsqr = 0;
                    let n = 0;
                    valuearray.forEach(values => {
                        values.data.forEach(reading => {
                            n++;
                            sumx += reading.year;
                            sumy += reading.value;
                            sumxy += reading.value * reading.year;
                            sumxsqr += reading.year * reading.year;
                        })
                    })
                    k = (n * sumxy - sumx * sumy) / (n * sumxsqr - sumx * sumx);
                    b = (sumy - k * sumx) / n;

                    return {k, b}
                },
                calculateMonthlyTrends(series) {
                    if (this.calculatedMonthlytrends.length > 0) return this.calculatedMonthlytrends;

                    let i;
                    let monthlyaverages = [];
                    series.data.map((year, yearindex) => {
                        monthlyaverages.push({year: year.info.year, data: []});
                        for (i = 0; i < 12; i++) {
                            monthlyaverages[yearindex].data.push({morningsum: 0, morningcount: 0, eveningsum: 0, eveningcount: 0, month: i+1});
                        }
                        year.data.map(tempdata => {
                            let monthindex = this.getDate(tempdata.date).getMonth();
                            if (tempdata.morning) {
                                monthlyaverages[yearindex].data[monthindex].morningcount++;
                                monthlyaverages[yearindex].data[monthindex].morningsum += tempdata.morning;
                            }
                            if (tempdata.evening) {
                                monthlyaverages[yearindex].data[monthindex].eveningcount++;
                                monthlyaverages[yearindex].data[monthindex].eveningsum += tempdata.evening;
                            }
                        })
                    });

                    let monthlytrenddata = [];
                    let monthindex;
                    for (monthindex = 0; monthindex < 12; monthindex++) {
                        monthlytrenddata.push({month: monthindex+1, data: []});
                        let monthlyvalues = monthlyaverages.map((year, index) => {
                            if (year.data[monthindex].eveningcount > 0 || year.data[monthindex].morningcount > 0) {
                                let value = (year.data[monthindex].eveningsum + year.data[monthindex].morningsum) / (year.data[monthindex].eveningcount + year.data[monthindex].morningcount);
                                monthlytrenddata[monthindex].data.push({year: year.year, month: monthindex+1, value: value});
                            }
                        })
                    }
                    this.calculatedMonthlytrends = monthlytrenddata;

                    return monthlytrenddata;
                },
                getSeasonTrends(series, monthnumbers, monthnames) {
                    let monthlytrenddata = this.calculateMonthlyTrends(series);

                    let datavalues = [];
                    let v = monthlytrenddata.map(month => {
                        if (month.month == monthnumbers[0] || month.month == monthnumbers[1] || month.month == monthnumbers[2]) {
                            let values = [];
                            let t = month.data.map(value => {
                                values.push({value: [new Date(value.year, 0, 1), this.roundNumber(value.value, 2)], tooltip: `${value.year} ${value.month} ${this.roundNumber(value.value, 2)}`});
                            });
                            datavalues.push({values: values, location: series.data[0].info.location, year: 0, name: monthnames[datavalues.length]});
                        }
                    });
                    let summertrend = this.calculateTrend([monthlytrenddata[monthnumbers[0]-1], monthlytrenddata[monthnumbers[1]-1], monthlytrenddata[monthnumbers[2]-1]]);
                    let newvalues = [];
                    series.data.map((ser, serieindex) => {
                        newvalues.push({value: [new Date(ser.info.year, 0, 1), this.roundNumber(ser.info.year * summertrend.k + summertrend.b, 2)], tooltip: `${ser.info.year} Suuntaus ${this.roundNumber(ser.info.year * summertrend.k + summertrend.b, 2)}`});
                    });
                    datavalues.push({values: newvalues, location: series.data[0].info.location, year: 0, name: `Trendi ${this.roundNumber(summertrend.k*10, 1)}°C/10v`});
                    return datavalues;
                },
                createMonthlySummerTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [6,7,8], ['Kesäkuu','Heinäkuu','Elokuu']);
                    /*
                    let values = [];
                    values.push({value: [datetime, reading], tooltip: ''})

                    let datavalues = [];
                    datavalues.push({values: values, location: '', year: 2000})

                    return {data: datavalues, params: null}
                    */
                    return {data: datavalues, params: {range: this.rangefit, offset: 1, showlegend: true}};
                },
                createMonthlyWinterTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [1,2,12], ['Tammikuu','Helmikuu','Joulukuu']);
                    return {data: datavalues, params: {range: this.rangefit, offset: 1, showlegend: true}};
                },
                createMonthlyFallTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [9,10,11], ['Syyskuu','Lokakuu','Marraskuu']);
                    return {data: datavalues, params: {range: this.rangefit, offset: 1, showlegend: true}};
                },
                createMonthlySpringTrendSeriedata(series) {
                    let datavalues = this.getSeasonTrends(series, [4,5,6], ['Huhtikuu','Toukokuu','Kesäkuu']);
                    return {data: datavalues, params: {range: this.rangefit, offset: 1, showlegend: true}};
                },
                createAllYearsMonthlyAverageSeriedata(series) {
                    let index;
                    let months = [];
                    let dailyvalues = this.createAllYearsAverageSeriedata(series);
                    dailyvalues.data.forEach((yeardata, ind) => {
                        let tempvalue;
                        let month;
                        months.push([]);
                        for (index = 0; index < 12; index++) months[ind].push({sum: 0, count: 0, average: NaN});
                        yeardata.values.forEach(dailyValues => {
                            month = dailyValues.value[0].getMonth();
                            tempvalue = dailyValues.value[1];
                            if (tempvalue) {
                                months[ind][month].count++;
                                months[ind][month].sum += tempvalue;
                            }
                        })
                        months[ind].forEach(m => { if (m.count > 0) m.average = m.sum / m.count; })
                    })
                    dailyvalues.data.forEach((monthdata, dataindex) => {
                        let newvalues = [];
                        let y = monthdata.values[0].value[0].getFullYear();
                        for (index = 0; index < months[dataindex].length; index++) {
                            let newdate = new Date(y, index, 1);
                            newvalues.push({tooltip: 'uusi', value: [newdate, months[dataindex][index].average]});
                        }
                        monthdata.values = newvalues;
                    })


                    return dailyvalues;
                },
                createAllYearsAverageSeriedata(series) {
                    const defaultyear = 1976;
                    let sums = [];
                    let dayindex;
                    let yearindex;
                    let index;
                    let value;
                    for (dayindex = 0; dayindex < 366; dayindex++) {
                        value = {date: new Date(defaultyear, 0, dayindex + 1), morning: {sum: 0, count: 0, average: NaN}, evening: {sum: 0, count: 0, average: NaN}, total: {sum: 0, count: 0, average: NaN}, day: 0, month: 0};
                        value.month = value.date.getMonth() + 1;
                        value.day = value.date.getDate();
                        sums.push(value);
                    }
                    let dayreadings;
                    let dt;
                    let month;
                    let day;
                    for (yearindex = 0; yearindex < series.data.length; yearindex++) {
                        for (dayindex = 0; dayindex < series.data[yearindex].data.length; dayindex++) {
                            dayreadings = series.data[yearindex].data[dayindex];
                            dt = new Date(dayreadings.datetimeUtc);
                            month = dt.getMonth() + 1;
                            day = dt.getDate();
                            let foundsum = sums.find(s => s.day == day && s.month == month);
                            if (foundsum) {
                                if (dayreadings.morning && this.isNumeric(dayreadings.morning)) {
                                    foundsum.morning.count += 1;
                                    foundsum.morning.sum += dayreadings.morning;
                                    foundsum.total.count += 1;
                                    foundsum.total.sum += dayreadings.morning;
                                }
                                if (dayreadings.evening && this.isNumeric(dayreadings.evening)) {
                                    foundsum.evening.count += 1;
                                    foundsum.evening.sum += dayreadings.evening;
                                    foundsum.total.count += 1;
                                    foundsum.total.sum += dayreadings.evening;
                                }
                            }
                        }
                    }
                    for (dayindex = 0; dayindex < sums.length; dayindex++) {
                        if (sums[dayindex].morning.count > 0) {
                            sums[dayindex].morning.average = sums[dayindex].morning.sum / sums[dayindex].morning.count;
                        }
                        if (sums[dayindex].evening.count > 0) {
                            sums[dayindex].evening.average = sums[dayindex].evening.sum / sums[dayindex].evening.count;
                        }
                        if (sums[dayindex].total.count > 0) {
                            sums[dayindex].total.average = sums[dayindex].total.sum / sums[dayindex].total.count;
                        }
                    }
                    let loc = null;
                    for (index = 0; index < series.data.length; index++) {
                        if (series.data[index].info.location !== loc) {
                            if (loc === null) loc = series.data[index].info.location;
                            else loc = loc + ', ' + series.data[index].info.location;
                        }
                    }
                    if (loc === null) loc = '';
                    
                    let valuearray1 = sums.map(s => ({
                            value: [s.date, s.morning.average],
                            tooltip: `Aamu ${this.getDateTxt(s.date, true)} ${this.roundNumber(s.morning.average,2)}`,
                    }))
                    let valuearray2 = sums.map(s => ({
                            value: [s.date, s.evening.average],
                            tooltip: `Ilta ${this.getDateTxt(s.date, true)} ${this.roundNumber(s.evening.average, 2)}`,
                    }))
                    let valuearray3 = sums.map(s => ({
                            value: [s.date, s.total.average],
                            tooltip: `Keskiarvo ${this.getDateTxt(s.date, true)} ${this.roundNumber(s.total.average, 2)}`,
                    }))
                    let returnvalues1 = {
                        values: valuearray1,
                        location: loc,
                        year: 0,
                        name: 'kaikki vuodet',
                    }
                    let returnvalues2 = {
                        values: valuearray2,
                        location: loc,
                        year: 0,
                        name: 'kaikki vuodet',
                    }
                    let returnvalues3 = {
                        values: valuearray3,
                        location: loc,
                        year: 0,
                        name: 'kaikki vuodet',
                    }
                    const seriedata = { 
                        data: [returnvalues1, returnvalues2, returnvalues3],
                        params: null
                    };
                    return seriedata;
                },
                //getSelection(seriedata) {
                    //let selection = {};
                    // seriedata.data.forEach(s => {
                    //     selection[s.name] = false;
                    // })
                    // if (seriedata.selected && seriedata.selected.length) {
                    //     seriedata.selected.forEach(s => {
                    //         selection[s] = true;
                    //     })
                    // }
                    //return selection;
                //}, 
            
                //initSerieLegends(data) {
                   // let selection = [];
                    // if (activation.playernumbers && activation.playernumbers.length) {
                    //     activation.playernumbers.forEach((pno, i) => {
                    //         let foundplayer = data.options.chartitems.find((item, index) => {
                    //             let matchplayer = item.name.match(/^(\d{1,2}) ./);
                    //             return (matchplayer && pno == Number(matchplayer[1]));
                    //         });
                    //         if (foundplayer) selection.push(foundplayer.name);
                    //     });
                    // }
                    // else if (activation.names && activation.names.length) {
                    //     return activation.names;
                    // }
                    //return selection;
                //},

            }
        }).mount('#app');

    </script>

</body>

</html>