<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilaseuranta</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://jspm.dev/vue@3/dist/vue.esm-browser.js"
          }
        }
        
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <script src="chartfunctions.js" defer></script>

    <style>

        .graphelement {
            width: 1100px;
            height: 380px;
        }
        .datatable,
        .datatable th,
        .datatable td {
            border: 1px solid;
            text-align: center;
        }
        .latestreadingtable,
        .latestreadingtable th,
        .latestreadingtable td  {
            border: 1px solid;
            text-align: center;
        }
        #daystat {
            border: 1px solid;
            text-align: center;
        }
        .forecast {
            background-color: lightgray;
            color: black;
        }
        .active {
            background-color: lightgreen;
        }
        .morninghigh {
            background-color: rgb(245, 113, 113);
        }
        .morninglow {
            background-color: rgb(174, 139, 255);
        }
        .eveninghigh {
            background-color: rgb(245, 113, 113);
        }
        .eveninglow {
            background-color: rgb(174, 139, 255);
        }
        .estimatedvalue {
            background-color: gray;
        }
        .diffvalue {
            background-color: yellow;
        }
        .actionbutton {
            background-color: lightblue;
        }
        .yearbutton {
            background-color: lightgray;
            border-radius: 4px;
            margin: 2px;
        }
        .yearbutton:hover {
            background-color: gray;
        }
        .yearbuttonselected {
            background-color: red;
            color: white;
        }
        .yearbuttonselected:hover {
            background-color: rgb(246, 130, 130);
            color: white;
        }
        .actionbutton.active {
            background-color: red;
            color: white;
        }
        .setmargin5 {
            margin: 5px;
        }
        .marginbottom5 {
            margin-bottom: 5px;
        }
        #loader2 {
            position: absolute;
            left: 200px;
            z-index: 1;
        }
        #daygraph {
            display: inline-block;
            width: 400px;
            height: 380px;
        }
        #currentdaygraph {
            display: inline-block;
            width: 380px;
            height: 200px;
        }
        #forecastgraph {
            display: inline-block;
            width: 400px;
            height: 380px;
        }
        .scrollbox {
            height: 400px;
            width: 520px;
            overflow: scroll;
        }
        #Error {
            color: red;
            font-size: 24px;
        }
        .hidden {
            display: none;
        }
        .graphtitle {
            font-size: 20px;
            font-weight: bold;
        }
        .backbutton {
            margin-bottom: 10px;
            border-radius: 10px;
            color: #fff;
            border-color: #0d6efd;;
            background-color: #0d6efd
        }
        .forecastbutton {
            margin-bottom: 10px;
            border-radius: 10px;
            color: #fff;
            border-color: #0d6efd;;
            background-color: #0d6efd
        }
        .loader {
            border: 5px solid #f3f3f3;
            /* Light grey */
            border-top: 5px solid #3498db;
            /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
        }        
        @media screen and (max-width: 1080px) {
            .scrollbox {
                height: 420px;
                width: 420px;
                overflow: scroll;
            }            
        } 
        @media screen and (max-width: 780px) {
            .hideifnarrow {display:none}
            .scrollbox {
                height: 400px;
                width: 290px;
                overflow: scroll;
            }        
        }        
    h2 {
        font-size: 8px;
    }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilaseuranta</h1>
            <h2>26.4.2025e</h2>
        </div>
        <div id="app" class="page-content">
            <div class="hiddenstart hidden">
                <button class="backbutton" @click="gotofrontpage">&laquo;Etusivu</button>
                <div id="hiddenbutton"></div>
            </div>
            <hr>
            <div class="hiddenstart hidden">Viimeisin havainto: {{ latestReading.localtime ? latestReading.localtime : '-' }}   {{ isNaN(latestReading.t2m) ? '-' : roundNumber(latestReading.t2m, 1) + '°C'}}</div>
            <table class="hiddenstart hidden" id="daystat">
                <tr><th v-for="title in dailyrecord.title">{{ title }}</th></tr>
                <tr v-for="row in dailyrecord.values">
                    <td v-for="value in row">{{ value }}</td>
                </tr>
            </table>
            <p class="graphtitle hidden hiddenstart">{{ daycharttitle }}</p>
            <div id="currentdaygraph"></div>

            <div id="loader1" class="loader hidden"></div>            
            <hr>
            <div id="Error"></div>
            <div class="row">
                <div class="col-6" :style="loading?'display:none;':'display:inline-block;'">
                    <readings :temperatures="listedtemperaturereadings" :selectedday="selectedday" :allreadings="alltemperaturereadings" :lastreadings="lastTemperatures" @dayselected="dayselected" @savefile="savefile" @forecastvalues="addforecasts"></readings>
                    <div id="loader2" class="loader hidden"></div>
                    <div class="hiddenstart hidden">
                        <button  class="yearbutton" v-for="item in listedtemperaturereadings.years" :class="{yearbuttonselected: this.selectedyearbutton == item.year }" @click="showselectedyear(item)">{{ item.year }}</button>
                    </div>
                </div>
                <div class="col-6" :style="!loading && selecteddayData.data[0].length>0?'display:inline-block;':'display:none;'">
                    <div class="hiddenstart hidden">
                        <button id="scrolldays" type="button" class="btn btn-primary setmargin5" @click="rundays">Rullaa</button>
                        <hr>
                        <p class="graphtitle">{{ dailycharttitle }}</p>
                        <div id="daygraph"></div>
                    </div>
                </div>
            </div>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph10" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph4" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph12" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph2" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles":title="''" :elemid="testgraph3" :active=true></trendgraph>
            <monthtable :title="'Kuukausittaiset lämpötilat'" :monthlydata="calculated.values.yearlyvalues" :monthaverages="calculated.values.monthlyvalues.temperature" :monthnames="monthnames" :datatype="'t'"></monthtable>
            <monthtable :title="'Kuukausittaiset lämpötilaerot'":monthlydata="calculated.values.yearlyvalues" :monthaverages="calculated.values.monthlyvalues.diff" :monthnames="monthnames" :datatype="'d'"></monthtable>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph11" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph5" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph6" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph7" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph8" :active=true></trendgraph>
            <trendgraph :titles="testgraphtitles" :title="''" :elemid="testgraph9" :active=true></trendgraph>

<!-- Latest readings modal start---------------------------------------------------------- -->
            <div id="loadModal" class="modal fade" tabindex="-1" aria-labelledby="loadModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="loadModalLabel">Viimeisimmät lukemat</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div id="loader3" class="loader hidden"></div>

                            <table class="latestreadingtable">
                                <tr>
                                    <th>Päivä</th><th>Aamu</th><th>Ilta</th><th>Aamu</th><th>Ilta</th>
                                </tr>
                            <tr v-for="item in latestReadingsFromNet">
                                <td>{{ isNaN(item.observation.morning) ?  item.observation.eveningtime.getDate() : item.observation.morningtime.getDate() }}.
                                    {{ isNaN(item.observation.morning) ?  item.observation.eveningtime.getMonth()+1: item.observation.morningtime.getMonth()+1 }}.
                                    {{ isNaN(item.observation.morning) ?  item.observation.eveningtime.getFullYear(): item.observation.morningtime.getFullYear()}}</td>
                                <td>{{ isNaN(item.observation.morning) ? '' : this.roundNumber(item.observation.morning, 1) }}</td>
                                <td>{{ isNaN(item.observation.evening) ? '' : this.roundNumber(item.observation.evening, 1) }}</td>
                                <td :class="this.getclass(item.reading.morning, item.observation.morning)">
                                    {{ this.printvalue(item.reading.morning, item.observation.morning) }}</td>
                                <td :class="this.getclass(item.reading.evening, item.observation.evening)">
                                    {{ this.printvalue(item.reading.evening, item.observation.evening) }}</td>
                                <td><input v-model="item.obsselected" :disabled="daydisabled(item)" type="checkbox" name="select"></td>
                            </tr>
                            </table>
                            <hr>
                            <input type="date" id="readingdate" name="readingdate" :value="editdate" @change="changeeditdate" min="2000-01-01" max="2029-12-31" />
                            <input type="number" name="morning" min="-35" max="35" v-model="editmorning"/>
                            <input type="number" name="evening" min="-35" max="35" v-model="editevening"/>
                            <button :disabled="!(!latestReadingsFromNet.saveenable || !latestReadingsFromNet.find(l => l.obsselected))" @click="savereading" type="button" class="btn btn-success">Tallenna arvo</button>
                        </div>
                        <div class="modal-footer">
                            <input type="checkbox" :disabled="!latestReadingsFromNet.saveenable" name="saveyeartemperatures">
                            <button  :disabled="!latestReadingsFromNet.saveenable || !latestReadingsFromNet.find(l => l.obsselected)" @click="savereadings" type="button" class="btn btn-success">Tallenna</button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Sulje</button>
                        </div>
                    </div>
                </div>
            </div>
<!-- Latest readings modal end----------------------------------------------------------- -->

<!-- Forecast modal start---------------------------------------------------------- -->
<div id="forecastModal" class="modal fade" tabindex="-1" aria-labelledby="forecastModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="forecastModalLabel">Viimeaikaiset ja ennuste</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="loader3" class="loader hidden"></div>
                
                <div id="forecastgraph"></div>

            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Sulje</button>
            </div>
        </div>
    </div>
</div>
<!-- Forecast modal end----------------------------------------------------------- -->
        </div>
    </div>

    <script type="module">


        import { createApp, ref } from 'vue'

        const months1 = ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'];
        const months2 = ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'];
        const NoSelection = -1;
        const StopScrolling = -2;
        let userguid = '';
        let givenyears = null;
        let location = '';

        function selectFirstDay() {
            let button = document.getElementsByClassName('daybutton_0');
            if (button && button.length) button[0].click();
            else setTimeout(() => { selectFirstDay(); }, 50);
        }

        (async function () {
            userguid = new URLSearchParams(document.location.search).get("userid");
            const years = new URLSearchParams(document.location.search).get("years");
            location = new URLSearchParams(document.location.search).get("location");
            if (years === null) givenyears = null;
            else {
                const yearlist = years.split(',')
                givenyears = {data: yearlist.map(y => Number(y))};
            }

//            setTimeout(() => { selectFirstDay(); }, 50);
        })();


        
        const vueapp = createApp({
            data() {
                return {
                    monthnames: months1,
                    monthnamesLong: months2,
                    givenyears: givenyears,

                    loading: ref(true),
                    location: location === null || location == '' ? 'Salo' : location,
                    
                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    testgraph9: 'GraphLocation9',
                    testgraph10: 'GraphLocation10',
                    testgraph11: 'GraphLocation11',
                    testgraph12: 'GraphLocation12',
                    testgraphtitles : [],

                    scrollday: {
                        firstdate: null,
                        selecteddate: null,
                        selecteddayindex: NoSelection,
                        scroll: false,
                    },
                    selectedday: 0, // not used
                    selecteddayData: {data: [[],[]], chart: null},
                    daycharttitle: '',
                    currentdayData: {data: [[],[]], chart: null},

                    calculated : {
                        values: {yearlyvalues: [], monthlyvalues: []},
                    },

                    alltemperaturereadings: { values: [], years: [], filtersize: 7 },    // all temperature values
                    listedtemperaturereadings: { values: [], years: [], filtersize: 7}, // contains values listed in table
                    lastTemperatures: [],
                    latestReadingsFromNet: [],
                    latestReading: {localtime:'', t2m: NaN},
                    dailycharttitle: '',

                    screenCharts: [],
                    forecastData: {data: [[],[]], chart: null},
                    selectedyearbutton: '',
                    monthlylimits: [],

                    editdate: '',
                    editmorning: '',
                    editevening: '',

                    dailyrecord:  {title: [], values: []},
                    latestdayvalues: [],
                }
            },
            async mounted() {
                await this.loadAll();
                this.updateFieldEdit(new Date());
            },
            components: {
                readings: {
                    props: ['temperatures', 'selectedday', 'allreadings', 'lastreadings', 'yearlyaverages'],
                    emits: ['dayselected', 'savefile', 'forecastvalues'],
                    data: function () {
                        return {
                            selected: ref(NoSelection),
                            sum: ref(0),
                            arrowup: String.fromCharCode(0x2191),
                            arrowdn: String.fromCharCode(0x2193),
                        }
                    },
                    // reading
                    computed: {
                        calculateAverage: function () {
                            this.sum = 0;
                        }
                    },
                    updated() {
                    },
                    // reading
                    methods: {
                        // reading
                        setSum(value) {
                            this.sum = value;
                        },
                        // reading
                        roundNumber(value, num) {
                            return roundNumber(value, num)
                        },
                        // reading
                        calcSums() {
                            let setvalue = this.setSum;
                            setTimeout(function () {
                                let elements = document.getElementsByClassName('xxx active');
                                if (elements.length == 0) {
                                    setvalue(0);
                                    return;
                                }
                                let sum = 0;
                                let count = 0;
                                for (var index = 0; index < elements.length; index++) {
                                    if (isNumeric(elements[index].innerText)) {
                                        sum += Number(elements[index].innerText);
                                        count++;
                                    }
                                }
                                if (count > 0) setvalue(sum / count);
                                else setvalue(-1);
                            }, 1)
                        },
                        // reading
                        getDateTxt(date) {
                            return getDateTxt(date);
                        },
                        // reading
                        selectDay(item) {
                            if (this.selected == item.index) this.selected = NoSelection;
                            else this.selected = item.index;
                            this.calcSums();
                            if (this.selected == item.index) {
                                const selecteddate = this.temperatures.values[this.selected].date.getDate();
                                const selectedmonth = this.temperatures.values[this.selected].date.getMonth();
                                let values = this.allreadings.values.map(r => {
                                    if (r && r.date && r.date.getDate() == selecteddate && r.date.getMonth() == selectedmonth) {
                                        return {date: r.date, value: r.average, morning: r.morning, evening: r.evening, datetimeLocal: r.date}
                                    }
                                    else return null
                                })
                                this.$emit('dayselected', {values: values.filter(v => v !== null), selected: this.selected});
                            }
                            else this.$emit('dayselected', {values: [], selected: StopScrolling});
                        },
                        // reading
                        markIfPressed(item) {
                            if (item.forecast === true) {
                                return {active: false, forecast: true}
                            }                            
                            if (this.selected < 0) return { active: false };
                            if (this.selected == item.index) return { active: true }
                            return { active: false };
                        },
                        // reading
                        getClass(index) {
                            return `daybutton_${index}`;
                        },
                        // reading
                        markIfSelected(item, mode) {
                            if (item.forecast === true) {
                                return {active: false, forecast: true}
                            }
                            if (this.selected < 0) return { active: false, 
                                morninghigh: (mode == 1 && item.morninghighest), morninglow: (mode == 1 && item.morninglowest),
                                eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest) 
                            };
                            return { active: item.date >= this.temperatures.values[this.selected].firstdayfilter &&
                                    item.date < this.temperatures.values[this.selected].lastdayfilter, 
                                    morninghigh: mode == 1 && item.morninghighest, morninglow: mode == 1 && item.morninglowest,
                                    eveninghigh: (mode == 2 && item.eveninghighest), eveninglow: (mode == 2 && item.eveninglowest)  }
                        },
                        // reading
                        saveValuestoFile() {
                            let data = this.allreadings.values.map(line => (
                                `${this.getDateTxt(line.date)}\t${roundNumber(line.morning, 1)}\t${roundNumber(line.evening, 1)}\t${roundNumber(line.averagefiltered, 1)}`
                            ));
                            let filename = 'readings.txt';
                            this.$emit('savefile', {data: `Päivämäärä\tAamu\tIlta\tSuodatettu(${this.allreadings.filtersize})\n${data.join('\n')}`,
                                filename: filename, message: `Tallennettu tiedostoon ${filename}`});
                        },
                    },
                    // reading
                    template: `
                        <p class="graphtitle">Lämpötilalukemat ja suodatettu arvo</p>
                        <button type="button" class="btn btn-primary marginbottom5" data-bs-toggle="modal" data-bs-target="#forecastModal">Ennuste</button>

                        <div><button type="button" class="btn btn-primary marginbottom5" @click="saveValuestoFile">Tallenna kaikki lukemat tiedostoon</button></div>
                        <div class="scrollbox">
                        <table class="datatable">
                            <thead><tr><td></td><td>Aamu</td><td>Ilta</td><td>Karvo</td><td class="hideifnarrow">Ero</td></tr></thead>
                            <tbody>
                                <tr v-for="(item, index) in temperatures.values">
                                    <td :class="markIfPressed(item)" align="center"> 
                                        <button class="actionbutton" @click="selectDay(item)" :class="markIfPressed(item),getClass(index)">
                                            {{ getDateTxt(item.date) }} 
                                        </button> 
                                    </td>
                                    <td class="xxx" :class="markIfSelected(item, 1)"> {{ roundNumber(item.morning, 1) }}{{ item.morninghighest ? this.arrowup : "" }}{{ item.morninglowest ? this.arrowdn : "" }}</td>
                                    <td class="xxx" :class="markIfSelected(item, 2)"> {{ roundNumber(item.evening, 1) }}{{ item.eveninghighest ? this.arrowup : "" }}{{ item.eveninglowest ? this.arrowdn : "" }} </td>
                                    <td :class="markIfPressed(item)"> {{ roundNumber(item.yearlyaverage, 1) }} </td>
                                    <td class="xxx hideifnarrow" :class="markIfSelected(item, 3)"> {{ roundNumber(item.average-item.yearlyaverage, 1) }} </td>
                                </tr>                                
                            </tbody>
                        </table>            
                        </div>            
                        `
                },
                monthtable: {
                    props: ['monthlydata', 'monthnames', 'monthaverages', 'title', 'datatype'],
                    emits: ['lastyear'],
                    // monthtable
                    methods: {
                        roundNumber(value, num) {
                            return roundNumber(value, num);
                        },
                        getTableTemperatureValue(m) {
                            if (isNaN(m.temperature)) return '-'
                            return `${m.estimate ? '(' : ''}${roundNumber(m.temperature, 1)}${m.estimate ? ')' : ''}`;
                        },
                        getTableDifferenceValue(m) {
                            if (isNaN(m.difference)) return '-'
                            return `${m.estimate ? '(' : ''}${roundNumber(m.difference, 1)}${m.estimate ? ')' : ''}`;
                        },
                    },
                    // monthtable
                    template: `
                        <hr>
                        <div class="hiddenstart hidden">
                        <p class="graphtitle">{{ title }}</p>
                        <table class="datatable">
                            <thead>
                                <tr>
                                    <th></th><th v-for="month in monthnames">{{ month }}</th>
                                    <th>Koko vuosi</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in monthlydata">
                                    <td>{{ item.year }}</td> 
                                    <td v-for="m in item.months">{{ datatype=="t" ? getTableTemperatureValue(m) : getTableDifferenceValue(m) }}</td>
                                    <td>{{ item.estimate===true ? '(': ''}}{{ datatype=="t" ? roundNumber(item.yearaverage, 1): roundNumber(item.yearaveragediff, 1) }}{{ item.estimate==true?')':''}}</td>
                                </tr>                                
                            </tbody>
                            <tfoot>
                                <tr>
                                    <th>Yht</th>
                                    <th v-for="value in monthaverages">{{ roundNumber(value,1) }}</th>
                                </tr>
                            </tfoot>
                        </table>
                        </div>
                        `
                },
                trendgraph: {
                    props: ['title', 'elemid', 'active', 'titles'],
                    template: `
                        <hr>
                        <div>
                            <p class="graphtitle">{{ titles[elemid] ? titles[elemid] : '' }}</p>
                            <div :class="{hidden: !active}" class="trendchart">
                                <div class="trendtitle"></div>
                                <div :id="elemid" class="graphelement"></div>
                            </div>
                        </div>
                        `
                }
            },
            methods: {
                gotofrontpage() {
                    window.location.href = `/?${userguid === null ? '' : 'userid=' + userguid + '&'}location=${this.location}`;
                },
                formatTime(t) {
                    return `${t.getDate()}.${t.getMonth()+1}.${t.getFullYear()} klo: ${t.getHours()}.${t.getMinutes() < 10 ? '0':''}${t.getMinutes()}`
                },
                createLatestReadinsChart(title) {
                    this.daycharttitle = title;
                    this.currentdayData.chart = this.createChart('currentdaygraph', 
                        this.daycharttitle, this.createCurrentDayGraph, this.selecteddayData.chart);
                },
                updateLatestReading(observations) {
                    if (observations && observations.observations.length) {
                        this.latestReading = observations.observations[observations.observations.length-1];
                        this.latestReading.localtime = this.formatTime(getStationTime(this.latestReading.localtime));

                        const curtime = new Date();
                        const lasttime = curtime.setDate(curtime.getDate()-1);
                        let dt;
                        let index = observations.observations.length-1;
                        this.latestdayvalues = [];
                        do {
                            index--;
                            dt = getStationTime( observations.observations[index].localtime);
                            if (dt >= lasttime) {
                                this.latestdayvalues.push({datetime: dt, value: observations.observations[index].t2m})
                            }
                        } while (index > 0 && dt > lasttime);
                        
                        this.currentdayData.data = this.latestdayvalues;
                        this.daycharttitle = 'Viimeiset lukemat';

                        this.currentdayData.chart = this.createChart('currentdaygraph', 
                            //this.daycharttitle, this.createCurrentDayGraph, this.selecteddayData.chart);
                            this.daycharttitle, this.createCurrentDayGraph, this.currentdayData.chart);

                    }
                },
                async loadAll() {
                    this.startSpinner(1);
                    let years = null;
                    if (this.givenyears === null) years = await apiGetYears(userguid, this.location);
                    else years = this.givenyears;

                    //years.data = [2024]

                    //const statistics = await apiGetStatistics(userguid, this.location, years.data, this.alltemperaturereadings.filtersize, months1, months2);
                    //CF2SetStatisticsdata({data: statistics.data.statistics})
                    //let temperatures = {data: statistics.data.readings};

                    let temperatures = await apiGetTemperatures(userguid, this.location, years.data);

                    if (temperatures.error)  {
                        this.stopSpinner(1);
                        document.getElementById('Error').innerText = temperatures.error.msg;
                        return;
                    }
                    this.checkData(temperatures);
                    this.lastTemperatures = this.getLastreadings(temperatures);
                    if (this.lastTemperatures.length == 0) {
                        this.stopSpinner(1);
                        document.getElementById('Error').innerText = "Ei lämpötilalukemia";
                        return;
                    }
                    const data = await apiAdminButton1(userguid);
                    if (data.statusCode == 200) {
                        const elem = document.getElementById('hiddenbutton');
                        if (elem) elem.innerHTML = data.data.html;
                    }

                    // initialize temperature readings
                    CFinitTemperature(temperatures, this.alltemperaturereadings.filtersize, this.monthnames, this.monthnamesLong);
                    const currentdate = new Date();
                    const currentday = currentdate.getDate();
                    const currentmonth = currentdate.getMonth();
                    let dailyvalues = { morninghigh: {value: -9999, year: 0},  morninglow: {value: 9999, year: 0},
                                   eveninghigh: {value: -9999, year: 0},  eveninglow: {value: 9999, year: 0}
                                }
                    const currentdayreadings = [];
                    temperatures.data.forEach( yeardata => yeardata.data.forEach(day => {
                        if (day.datetimeLocal.getDate() == currentday && day.datetimeLocal.getMonth() == currentmonth)  currentdayreadings.push(day);
                        }
                    ))
                    const morningsum = currentdayreadings.reduce((partialSum, a) => partialSum + a.morning, 0);
                    const eveningsum = currentdayreadings.reduce((partialSum, a) => partialSum + a.evening, 0);
                    currentdayreadings.forEach(day => {
                        if (day.morning > dailyvalues.morninghigh.value ) {dailyvalues.morninghigh.value = day.morning; dailyvalues.morninghigh.year = day.datetimeLocal.getFullYear();}
                        if (day.morning < dailyvalues.morninglow.value) {dailyvalues.morninglow.value = day.morning; dailyvalues.morninglow.year = day.datetimeLocal.getFullYear();}
                        if (day.evening > dailyvalues.eveninghigh.value) {dailyvalues.eveninghigh.value = day.evening; dailyvalues.eveninghigh.year = day.datetimeLocal.getFullYear();}
                        if (day.evening < dailyvalues.eveninglow.value) {dailyvalues.eveninglow.value= day.evening; dailyvalues.eveninglow.year = day.datetimeLocal.getFullYear();}
                    })
                    this.dailyrecord.title = [`${currentday}.${currentmonth+1}`, 'Aamu', 'Ilta'];
                    this.dailyrecord.values = [];
                    this.dailyrecord.values.push(['keskiarvo', roundNumber(morningsum/(currentdayreadings.length-1), 1), roundNumber(eveningsum/(currentdayreadings.length-1), 1)]);
                    this.dailyrecord.values.push(['ylin', dailyvalues.morninghigh.value + "°C /" + dailyvalues.morninghigh.year, dailyvalues.eveninghigh.value + "°C /" + dailyvalues.eveninghigh.year]);
                    this.dailyrecord.values.push(['alin', dailyvalues.morninglow.value + "°C /" + dailyvalues.morninglow.year, dailyvalues.eveninglow.value + "°C /" + dailyvalues.eveninglow.year]);


                    this.alltemperaturereadings = CFgetAllReadings();
                    this.listedtemperaturereadings.filtersize = this.alltemperaturereadings.filtersize;
                    this.listedtemperaturereadings.values = [];
                    const temp = this.alltemperaturereadings.values.map((v, i) => ({year: v.date.getFullYear(), index: i}));
                    let prev = '';
                    this.listedtemperaturereadings.years = temp.filter(v => { let returnvalue = v.year != prev; prev = v.year; return returnvalue;});
                    this.fillTemperaturereadingtable(0, this.listedtemperaturereadings.values, this.alltemperaturereadings.values[0].date.getFullYear(), this.stoploading);
    
                    // initialize graphics curves
                    this.calculated.values = CFcalculateMonthlyAverages();
                    this.monthlylimits = this.calculated.values.monthlystatvalues;
    
                    this.createChart(this.testgraph10, 'Suodatetut lämpötilat', CFcreateYearlyFilteredSeriedata);
                    this.createChart(this.testgraph2, 'Päivittäiset keskiarvot', CFcreateAllYearsAverageSeriedata);
                    this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', CFcreateAllYearsMonthlyAverageSeriedata);
                    this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', CFcreateAllYearsFilteredSeriedata);
                    this.createChart(this.testgraph4, 'Viimeinen vuosi', CFcreateLastYearsSeriedata);
                    this.createChart(this.testgraph9, 'Aamun ja illan ero (suodatettu)', CFcreateDailyDiffdata);
                    this.createChart(this.testgraph12, 'Ennätyslämpötilat/vuosi (kpl)', CFcreateYearlyHighValuedata);
                    this.createChart(this.testgraph11, 'Vuosittainen suuntaus', CFcreateYearlyTrendSeriedata);

                    let yearlyAverages = getYearlyAverageSerie();
                    this.listedtemperaturereadings.values.forEach(item => {
                        let founddate = yearlyAverages.values.find(v => v.date.getMonth() == item.date.getMonth() && v.date.getDate() == item.date.getDate())
                        if (founddate) {
                            item.yearlyaverage = founddate.value;
                        }
                    })

                    this.screenCharts.push(this.createChart(this.testgraph5, 'Kesän suuntaus', CFcreateMonthlySummerTrendSeriedata));
                    this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                    this.screenCharts.push(this.createChart(this.testgraph6, 'Talven suuntaus', CFcreateMonthlyWinterTrendSeriedata));
                    this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                    this.screenCharts.push(this.createChart(this.testgraph7, 'Syksyn suuntaus', CFcreateMonthlyFallTrendSeriedata));
                    this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                    this.screenCharts.push(this.createChart(this.testgraph8, 'Kevään suuntaus', CFcreateMonthlySpringTrendSeriedata));
                    this.screenCharts[this.screenCharts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);
                    //CF2setOperationMode(0);

                    let itemlist = document.querySelectorAll(".hiddenstart.hidden");
                    if (itemlist && itemlist.length) itemlist.forEach(i => i.classList.remove("hidden"))

                    this.createLatestReadinsChart('Viimeiset lukemat');

                    const funct = this.updateLatestReading;
                    apiGetLatestTemperatures3(this.location, 2)
                        .then(res => {
                            funct(res); 
                         }
                        )
                        .catch(error => {
                            console.log(error)
                        });

                    // this.updateLatestReading(await apiGetLatestTemperatures3(this.location, 2));

                    this.stopSpinner(1);
                    
                    setTimeout(() => {
                        let elem = document.getElementById('loadModal');
                        if (elem) {
                            elem.addEventListener('show.bs.modal', async () => {
                                // get latest readings when modal opened
                                this.startSpinner(3);

                            //     const saving = await apiGetSavingAllowed(userguid);
                            //     this.latestReadingsFromNet.saveenable = saving.data.access;
                            //     apiGetLatestTemperatures3(this.location, 7).then(stationreadings => {
                            //         this.updateLatestReading(stationreadings);

                            //         let temp = this.latestReadingsFromNet.saveenable;
                            //         this.latestReadingsFromNet = compareReadings(this.lastTemperatures, stationreadings);
                            //          this.latestReadingsFromNet.saveenable - temp;
                            //     })
                            //     .catch(error => {
                            //         console.log(error)
                            //     });

                                const stationreadings = await apiGetLatestTemperatures3(this.location, 7);
                                this.latestReadingsFromNet = compareReadings(this.lastTemperatures, stationreadings);
                                const saving = await apiGetSavingAllowed(userguid);
                                this.latestReadingsFromNet.saveenable = saving.data.access;
                                this.updateLatestReading(stationreadings);
                                this.updateFieldEdit(new Date());

                                this.stopSpinner(3);
                            });                     
                        }
                        elem = document.getElementById('forecastModal');
                        if (elem) {
                            elem.addEventListener('show.bs.modal', async () => {
                                //this.lastreadings;
                                let series = [[], []];
                                apiGetForecast2(this.location). then(resp => {
                                    this.forecastData.data = resp; 
                                    setTimeout(() => {
                                        this.forecastData.chart = this.createChart('forecastgraph', 
                                        "Ennuste", this.createForecastGraph, this.forecastData.chart);                                       
                                    }, 200);
                                })
                                this.forecastData.chart = this.createChart('forecastgraph', 
                                    "Ennuste", this.createForecastGraph, this.forecastData.chart);

                                // this.forecastData.data = await apiGetForecast2(this.location);
                                // this.forecastData.chart = this.createChart('forecastgraph', 
                                //     "Ennuste", this.createForecastGraph, this.forecastData.chart);

                            })
                        }
                        document.addEventListener('hide.bs.modal', function (event) {
                            if (document.activeElement) {
                                document.activeElement.blur();
                            }
                        });
                    }, 10);
                    setTimeout(() => { selectFirstDay(); }, 50);
                },
                stoploading() {
                    this.loading = false;
                },
                mainpage() {
                    window.location.href = `./charts.html?${userid === null ? '' : userid=userid + '&'}years=${yearparams}`;
                },
                roundNumber(value, num) {
                    return roundNumber(value, num)
                },
                startSpinner(no) {
                    const elem = document.getElementById(`loader${no}`);
                    if (elem) elem.classList.remove('hidden');
                },
                stopSpinner(spinnerno) {
                    if (spinnerno) {
                        const elem = document.getElementById(`loader${spinnerno}`);
                        if (elem) elem.classList.add('hidden');
                    }
                    const elems = document.getElementsByClassName('loader')
                    if (elems) {
                        for (var i = 0; i < elems.length; i++) elems[i].classList.add('hidden');
                    }
                },     
                getclass(reading, observation) {
                    return isNaN(observation) ? (isNaN(reading) ? '' : 'estimatedvalue') : 
                                    !isNaN(reading) && reading != observation ? 'diffvalue' : '' 
                },
                printvalue(reading, observation) {
                    return isNaN(reading) ? '' : this.roundNumber(reading, isNaN(observation) ? 0 : 1)
                },
                daydisabled(item) {
                    let selected = this.latestReadingsFromNet.find(i => i.obsselected);
                    if (selected != null) {
                        if (selected.date.getFullYear() != item.date.getFullYear()) return true;
                    };

                    if (((!isNaN(item.observation.morning) && isNaN(item.reading.morning)) ||
                        (!isNaN(item.observation.evening) && isNaN(item.reading.evening))) == true) {
                        return false;
                    }
                    if (!isNaN(item.observation.morning) && !isNaN(item.reading.morning)) {
                        if (item.observation.morning !== item.reading.morning) return false;
                    }
                    if (!isNaN(item.observation.evening) && !isNaN(item.reading.evening)) {
                        if (item.observation.evening !== item.reading.evening) return false;
                    }
                    return true;
                },
                savefile(params) {
                    this.saveToFile(params.data, params.filename, params.message, '')
                },
                addforecasts(values) {
                    if (this.listedtemperaturereadings.values[0].forecast === true) {
                        let i = 0;
                        while (i < this.listedtemperaturereadings.values.length && this.listedtemperaturereadings.values[i].forecast == true) {
                            i++;
                        }
                        if (i > this.listedtemperaturereadings.values.length) this.listedtemperaturereadings = [];
                        else {
                            this.listedtemperaturereadings.values.splice(0, i);
                        }
                        return;
                    }
                    values.data.forEach((d, i) => {
                        this.listedtemperaturereadings.values.splice(0, 0, {date: d.date, evening: d.evening, morning: d.morning, averagefiltered: null, average: (d.morning+d.evening)/2, forecast: true});
                    })
                },
                saveToFile(dataToSave, fileName, successmsg, eventname) {
                    var gameblob = new Blob([dataToSave], { type: 'text/plain' })
                                        if (this.objUrl !== null) window.URL.revokeObjectURL(this.objUrl);
                    this.objUrl = (window.webkitURL || window.URL).createObjectURL(gameblob);
                    var anchor = document.createElement('a');
                    anchor.download = fileName;
                    anchor.href = this.objUrl;
                    anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
                    anchor.click();
                    // document.querySelector("body").dispatchEvent(
                    //     new CustomEvent(eventname, {
                    //         bubbles: true,
                    //         detail: { text: () => successmsg },
                    //     })
                    // );
                },      
                changeeditdate(event) {
                    const date = event.target.value.split('-');
                    if (date && date.length == 3) {
                        const year = Number(date[0]);
                        const month = Number(date[1]);
                        const day = Number(date[2]);                       
                        this.updateFieldEdit(new Date(year, month-1, day));
                    }
                },       
                updateFieldEdit(today) {
                    this.editdate = `${today.getFullYear()}-${today.getMonth()<9?'0':''}${today.getMonth()+1}-${today.getDate()<10?'0':''}${today.getDate()}`;
                    let item = this.lastTemperatures.find(v => v.datetimeLocal.getFullYear() == today.getFullYear() &&
                        v.datetimeLocal.getMonth() == today.getMonth() && v.datetimeLocal.getDate() == today.getDate());
                    if (!item) {
                        item = this.alltemperaturereadings.values.find(v => v.date.getFullYear() == today.getFullYear() &&
                            v.date.getMonth() == today.getMonth() && v.date.getDate() == today.getDate());
                    }
                    if (item) {
                        this.editmorning = item.morning;
                        this.editevening = item.evening;
                    }
                    else {
                        this.editmorning = '';
                        this.editevening = '';
                    }
                },
                createDbDate(date)  {
                    return `${date.getMonth()+1}/${date.getDate()}/${date.getFullYear()}`;
                },
                async savereading() {
                    let d = this.editdate.split('-');

                    function getTemperature(temp) {
                        if (temp && temp != '') {
                            return Number(temp)
                        }
                        return '';
                    }
                    if (d && d.length == 3) {
                        let date  = new Date(d[0], Number(d[1])-1, d[2]);
                        let morning = getTemperature(this.editmorning);
                        let evening = getTemperature(this.editevening);
                        let tobesaved = {date: this.createDbDate(date), 
                            morning: morning, 
                            evening: evening, 
                            morningtime: new Date(date.getFullYear(), date.getMonth(), date.getDate(), 7), 
                            eveningtime: new Date(date.getFullYear(), date.getMonth(), date.getDate(), 15)};
                        let status = await apiSaveReadings(userguid, userguid, [tobesaved]);
                    }
                },
                async savereadings() {
                    let tobesaved = this.latestReadingsFromNet.map(l => l.obsselected ? 
                        {date: this.createDbDate(l.date), morning: l.observation.morning, evening: l.observation.evening, morningtime: l.observation.morningtime, eveningtime: l.observation.eveningtime}
                         : null).filter(a => a !== null);

                    if (tobesaved.length && this.latestReadingsFromNet.saveenable) {
                        // save selected readings
                        let status = await apiSaveReadings(userguid, userguid, tobesaved);
                        if (status.statusCode == 200) {
                            if (status.data.msg.saved == true) {
                                let button = document.getElementsByClassName('daybutton_0');
                                if (button && button.length) button[0].click();
                                bootstrap.Modal.getInstance(document.getElementById('loadModal')).hide();
                                await this.loadAll();
                                let elems = document.getElementsByName("saveyeartemperatures");
                                if (elems && elems.length) {
                                    if (elems[0].checked == true && status.data.msg.record.length) {
                                        this.saveToFile(JSON.stringify(status.data.msg.record[0].readings, null, 4), 'LatestRecord.json', 'Tallennus tehty', '');
                                    }
                                }
                            }
                            else {
                                alert(`Not saved, Debugging on`)
                            }
                        }
                        else alert(`Debugging on: ${status.data.msg}`)
                    }
                },
                showselectedyear(item) {
                    this.dayselected({selected: NoSelection, values: []});
                    this.startSpinner(2);
                    this.listedtemperaturereadings.values = [];
                    setTimeout( () => {this.fillTemperaturereadingtable(item.index, this.listedtemperaturereadings.values, this.alltemperaturereadings.values[item.index].date.getFullYear(), this.stopSpinner)}, 10);
                },
                fillTemperaturereadingtable(index, desttable, year, stopFunc) {
                    const maxyears = 2;
                    let i;
                    let counter = 0;
                    for (i = index; i < this.alltemperaturereadings.values.length && i < index + 1000 && this.alltemperaturereadings.values[i].date.getFullYear() > year-maxyears;i++) {
                        desttable.push(this.alltemperaturereadings.values[i]);
                        desttable[desttable.length-1].index = counter++;
                    }
                    this.selectedyearbutton = year.toString();
                    if (i < this.alltemperaturereadings.values.length && this.alltemperaturereadings.values[i].date.getFullYear() > year-maxyears) setTimeout(fillTemperaturereadingtable, 200, i, desttable, year);
                    else stopFunc();
                },
                monthlytrendcallback(params) {
                    const seriestatus = Object.keys(params.selected).map(k => ({status: params.selected[k], name: k}));
                    let i = 0;
                    let chart = null;
                    while (!chart && i < this.screenCharts.length) {
                        let j = 0;
                        while (j < this.screenCharts[i].serieOptions.series.length && !chart) {
                            // only one serie cheked, maybe should be more
                            let search = seriestatus.find(s => this.screenCharts[i].serieOptions.series[j].trend == false && this.screenCharts[i].serieOptions.series[j].name == s.name);
                            if (search) chart = this.screenCharts[i];
                            else j++;
                        }
                        if (!chart) i++;
                    }
                    if (!chart) return;

                    const series = chart.serieOptions.series.map(d => {
                        let search = seriestatus.find(s => s.name == d.name);
                        if (!d.trend && search && search.status === true) {
                            // serie active
                            return {
                                name: d.name,
                                num: d.num,
                                data: d.data.map(val => ({
                                    value: isNumeric(val.value[1]) ? Number(val.value[1]) : NaN,
                                    year:  val.value[0].getFullYear(),
                                }))
                            }
                        }
                        return null;
                    }).filter(v => v !== null);

                    const originaltrendserie = chart.serieOptions.series.find(d => d.trend == true);
                    if (!originaltrendserie) return;
                    const tempserie = {data: chart.serieOptions.series[0].data.map(ss => ({info: {year: ss.value[0].getFullYear(), location: ''}}))};
                    const temp = createTrendForGivenMonths(series.map(s => s.num), series.map(s => s.name));
                    const datavalues = temp.values;
                    const newtrendserie = datavalues.find(d => d.trend == true);
                    if (!newtrendserie) return;
                    originaltrendserie.data = newtrendserie.values.map(v => v);
                    originaltrendserie.name = newtrendserie.name;
                    chart.trendChart.setOption(chart.serieOptions);
                },                
                checkData(temperatures) {
                    temperatures.data.forEach(t => {
                        const year = t.info.year;
                        let prevdate = Number.MIN_VALUE;
                        t.data.forEach(d => {
                            if (d.datetimeLocal.getFullYear() !== year) {
                                alert(`Invalid year ${d.date.getFullYear()}`);
                            }
                            if (prevdate >= d.datetimeLocal + 1) {
                                console.log(`Invalid date ${d.datetimeLocal.getDate(0)}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`);
                                alert(`Invalid date ${d.datetimeLocal.getDate(0)}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`);
                            }
                            prevdate = d.datetimeLocal;
                        })
                    })
                    
                    let prevdate = Number.MIN_VALUE;
                    temperatures.data.forEach(t => {
                        t.data.forEach(d => {
                            if (d.datetimeLocal.getDate() == 14 && d.datetimeLocal.getMonth() == 1) {
                                prevdate=prevdate;
                            }
                            if (prevdate > Number.MIN_VALUE+100) {
                            if (prevdate > 0 && (d.datetimeLocal-prevdate < 86400000-3600000 || d.datetimeLocal-prevdate > 86400000+3600000)) {
                                const diffTime = Math.abs(d.datetimeLocal - prevdate);
                                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24))-1; 
                                const txt = `Missing date(s) between: ${prevdate.getDate()}.${prevdate.getMonth()+1}.${prevdate.getFullYear()} and ${d.datetimeLocal.getDate()}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()} (${diffDays})`;
                                //alert(txt)
                                console.log(txt)
                            }
                            else
                                if (typeof(d.morning) == 'undefined' || typeof(d.evening) == "undefined") {
                                    if (d.datetimeLocal.getFullYear() == 2024 && d.datetimeLocal.getMonth() == 1) {
                                        prevdate=prevdate;
                                    }
                                    let value = typeof(d.morning) == 'undefined' ? "morning" : "evening";
                                    let txt = `Missing ${value} value at: ${d.datetimeLocal.getDate()}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`;
                                    //alert(txt)
                                    console.log(txt)
                            
                                }
                            }
                            prevdate = d.datetimeLocal;
                        })
                    })
                    
                },
                //------------------------------------------------------------------------------
                createChart(element, title, funct, thischart) {
                    this.testgraphtitles[element] = title;
                    let trendChart = (thischart ? thischart.trendChart : this.initSerie(element));
                    if (trendChart === null) return;
                    const buildValues = funct();
                    const params = buildValues.params;
                    let serieOptions = this.buildChartOptions(title, buildValues);

                    trendChart.setOption(serieOptions);
                    return {trendChart, serieOptions, params};
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                getMinMaxValue(series) {
                    let min = getTempMinDefaultValue();
                    let max = getTempMaxDefaultValue();
                    series.data.forEach(s => {
                        s.values.forEach(point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return { min: min, max: max }
                },
                getSelection(seriedata, selectedseries) {
                    let selection = {};
                    seriedata.data.forEach(s => {
                        selection[s.name] = false;
                    })
                    if (selectedseries && selectedseries.length) {
                        selectedseries.forEach(s => {
                            selection[s] = true;
                        })
                    }
                    return selection;
                },                
                buildChartOptions(title, series) {
                    const monthnames = this.monthnames;
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: '',//title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function (value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (series.params && series.params.legend && series.params.legend.items) {
                                        return series.params.legend.items[m];
                                    }
                                    if (series.params && series.params.legend && series.params.legend.date) {
                                        return `${d}.${m+1}`
                                    }
                                    if (y == defaultYear()) return monthnames[m];
                                    if (series.params.axistime && series.params.axistime === true) {
                                        return `${v.getHours()}.${v.getMinutes()<10?v.getMinutes():''}${v.getMinutes()}`
                                    }
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series, series.params),
                        legend: {
                            show: false,
                            textStyle: { color: '#f0f', fontSize: '16' },
                        },
                    };
                    if (series.params) {
                        if (series.params.xaxisname) {
                            chartoptions.yAxis.name = series.params.xaxisname;
                        }
                        if (series.params.rangeoffset != null) {
                            let minmax = this.getMinMaxValue(series);
                            let offset = Number(series.params.rangeoffset);
                            chartoptions.yAxis.min = roundNumber(minmax.min - offset - 1, 0);
                            chartoptions.yAxis.max = roundNumber(minmax.max + offset, 0);
                        }
                        if (series.params.rangemin != null) {
                            chartoptions.yAxis.min = series.params.rangemin;
                        }
                        if (series.params.rangemax != null) {
                            chartoptions.yAxis.max = series.params.rangemax;
                        }
                        if (series.params.showlegend) {
                            chartoptions.legend.show = true;
                        }
                        if (series.params.selection) {
                            chartoptions.legend.selected = this.getSelection(series, series.params.selection);
                        }
                        if (series.params.axistime && series.params.axistime === true) {
                            // no operation here
                        }
                    }

                    return chartoptions;
                },
                //------------------------------------------------------------------------------
                dayselected(data) {
                    this.selectedday = data.selected;
                    // create trend curve
                    if (data.selected >= 0 || data.selected == StopScrolling) {
                        this.scrollday.selecteddayindex = data.selected;
                        this.stopdays();
                    }
                    const values = {
                        data: data.values.map(d => ({
                            value: d.value,
                            year: d.date.getFullYear(),
                            date: d.date,
                        }))
                    }
                    const factors = CFcalculateTrend([values]);
                    let trend = data.values.map(d => ({
                        value: d.date.getFullYear() * factors.k + factors.b,
                        date: d.date,
                    }))
                    let series = [data.values, trend];
                    this.selecteddayData.data = series;
                    this.dailycharttitle = `Päivän ${values.data.length ? values.data[0].date.getDate() : ''}.${values.data.length ? values.data[0].date.getMonth()+1 : ''} vuosittaisarvot (${factors.k > 0 ? '+' : ''}${roundNumber(factors.k * 10, 1)}°C/10v)`;
                    this.selecteddayData.chart = this.createChart('daygraph', 
                        this.dailycharttitle, this.createDayGraph, this.selecteddayData.chart);
                },
                rundays() {
                    if (this.scrollday.scroll == false) {
                        let elem = document.getElementById('scrolldays');
                        elem.innerText='Lopeta rullaus';
                        this.scrollday.scroll = true;
                        this.scrollday.firstdate = this.scrollday.selecteddate = this.listedtemperaturereadings.values[this.scrollday.selecteddayindex].date;
                        setTimeout(this.scrolldayfunction, 1);
                    }
                    else {
                        this.stopdays();
                    } 
                },
                stopdays() {
                    let elem = document.getElementById('scrolldays');
                    elem.innerText='Rullaa';
                    this.scrollday.scroll = false;
                    this.scrollday.selecteddate = this.scrollday.firstdate = null;
                },
                scrolldayfunction() {
                    if (this.scrollday.selecteddate === null) return;

                    let newday = new Date(this.scrollday.selecteddate.getFullYear(), this.scrollday.selecteddate.getMonth(), this.scrollday.selecteddate.getDate() - 1);
                    if (newday <= new Date(this.scrollday.firstdate.getFullYear() - 1, this.scrollday.firstdate.getMonth(), this.scrollday.firstdate.getDate())) {
                        this.scrollday.selecteddate =  this.scrollday.firstdate;
                    }
                    else this.scrollday.selecteddate = newday;

                    const selecteddate = this.scrollday.selecteddate.getDate();
                    const selectedmonth = this.scrollday.selecteddate.getMonth();
                    let values = this.alltemperaturereadings.values.map(r => {
                        if (r && r.date && r.date.getDate() == selecteddate && r.date.getMonth() == selectedmonth) {
                            return {datetimeLocal: r.date, date: r.date, value: r.average, morning: r.morning, evening: r.evening}
                        }
                        else return null
                    }).filter(v => v !== null);

                    this.dayselected({values: values, selected: NoSelection});
                    setTimeout(this.scrolldayfunction, 200);
                },
                getDateTxt(date, daymonth) {
                    return getDateTxt(date, daymonth == true ? true : false);
                },
                createSeries(series, params) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 4,
                        symbol: 'circle',
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                        trend: values.trend,
                        num: values.index,
                    }))

                    if (params) {
                        if (params.series) {
                            params.series.forEach(p => {
                                if (p.name == '') {
                                    // apply to all series
                                    if (p.markersize !== undefined) {
                                        chartdata.forEach(chart => {
                                            chart.symbolSize = p.markersize;
                                        })
                                    }
                                }
                            })
                            chartdata.forEach(d => {
                                let found = params.series.filter(p => p.name === d.name);
                                if (found && found.length) {
                                    d.symbolsize = 1;
                                    if (found.color) d.lineStyle = { color: found.color }

                                    if (found.symbolindex == 'last') {
                                        if (d.data.length) {
                                            d.data[d.data.length-1].symbol = found.symbol;
                                            d.data[d.data.length-1].symbolSize = found.symbolsize;
                                        }
                                    }
                                    else {
                                        let i = 0;
                                        while (i < found.length) {
                                            if (d.data[found[i].symbolindex]) {
                                                if (found[i].symbol) d.data[found[i].symbolindex].symbol = found[i].symbol;
                                            }
                                            if (d.data[found[i].symbolindex]) {
                                                if (found[i].symbolsize) d.data[found[i].symbolindex].symbolSize = found[i].symbolsize;
                                            }
                                            i++;
                                        }
                                    }
                                }
                            })
                        }
                    }
                    return chartdata;
                },
                createCurrentDayGraph() {
                    let datavalues = [];
                    let readings = [];
                    this.latestdayvalues.forEach(reading => { 
                        readings.push({value: [reading.datetime, reading.value], 
                            tooltip: `Klo ${reading.datetime.getHours()}:${reading.datetime.getMinutes()<10?'0':''}${reading.datetime.getMinutes()} ${roundNumber(reading.value, 1)}`});
                    })
                    datavalues.push({values: readings, location: '', year: -1});
                    return {data: datavalues, params: {axistime: true}};
                },
                createDayGraph() {
                    let datavalues = [];
                    this.selecteddayData.data.forEach((serie, i) => {
                        let values = serie.map(dd => (
                            {value: [dd.date, dd.value], tooltip: `Päivä: ${this.getDateTxt(dd.date, false)} ${roundNumber(dd.value, 1)}`}
                        ))
                        datavalues.push({values: values, location: '', year: 0});
                    });
                    const month =  datavalues.length > 0 && datavalues[0].values.length > 0 ?  datavalues[0].values[0].value[0].getMonth() : -1;
                    let limits = month >= 0 ? this.monthlylimits[month] : {min: -20, max: 20};
                    return {data: datavalues, params: {rangemin: limits.min, rangemax: limits.max}}
                },
                createForecastGraph() {
                    const latestreadingsamount = 28;

                    const forecastvalues = this.forecastData.data.map(data => ({
                        value: [new Date(data.localtime), data.temperature], 
                        tooltip: `Päivä: ${new Date(data.localtime).getDate()}.${new Date(data.localtime).getMonth()+1} klo ${new Date(data.localtime).getHours()} ${roundNumber(data.temperature, 1)}`
                    }));

                    let latestvalues = [];
                    this.lastTemperatures.forEach((data => {
                        if (data.morning) {
                            const date = new Date(data.datetimeLocal.getFullYear(), data.datetimeLocal.getMonth(), data.datetimeLocal.getDate(), 7);
                            latestvalues.push({value: [date,data.morning], 
                                tooltip: `Päivä: ${date.getDate()}.${date.getMonth()+1} klo ${date.getHours()} ${roundNumber(data.morning, 1)}`})
                        }
                        if (data.evening) {
                            const date = new Date(data.datetimeLocal.getFullYear(), data.datetimeLocal.getMonth(), data.datetimeLocal.getDate(), 15);
                            latestvalues.push({value: [date, data.evening], 
                                tooltip: `Päivä: ${date.getDate()}.${date.getMonth()+1} klo ${date.getHours()} ${roundNumber(data.evening, 1)}`})
                        }
                    }))
                    if (latestvalues.length > latestreadingsamount) {
                        latestvalues = latestvalues.splice(latestvalues.length - latestreadingsamount, latestvalues.length - latestreadingsamount)
                    }
                    const returndata = [
                        {name: "Viimeiset", values: latestvalues, year: 0, location: ''},
                        {name: 'Ennuste', values: forecastvalues, year: 0, location: ''},
                    ]
                    const params = {showlegend: true, legend: {date: true}}
                    return {data: returndata, params: params}
                },
                getLastreadings(temperatures) {
                    const lasttemperaturesamount = 50;
                    let lastTemperatures = [];
                    if (temperatures.data.length <= 0 ) return [];
                    if (temperatures.data.length > 1 && temperatures.data[temperatures.data.length - 1].data.length < lasttemperaturesamount) {
                        let last = temperatures.data[temperatures.data.length - 2].data.length;
                        const first = last - (lasttemperaturesamount - temperatures.data[temperatures.data.length - 1].data.length)
                        for (var i = first; i < last; i++) {
                            lastTemperatures.push(temperatures.data[temperatures.data.length - 2].data[i]);
                        }
                        for (var i = 0; i < temperatures.data[temperatures.data.length - 1].data.length; i++) {
                            lastTemperatures.push(temperatures.data[temperatures.data.length - 1].data[i]);
                        }
                    }
                    else {
                        let first = temperatures.data[temperatures.data.length - 1].data.length - lasttemperaturesamount;
                        for (var i = first; i < temperatures.data[temperatures.data.length - 1].data.length; i++) {
                            lastTemperatures.push(temperatures.data[temperatures.data.length - 1].data[i]);
                        }
                    }
                    return lastTemperatures;
                },

                //-end of methods-----------------------------------------------------------------------------
            }
        }).mount('#app');

    </script>

</body>

</html>