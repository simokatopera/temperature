<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilat</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <script src="chartfunctions.js" defer></script>

    <style>
        .graphelement {
            width: 1200px;
            height: 380px;
        }

        .datatable,
        .datatable th,
        .datatable td {
            border: 1px solid;
            text-align: center;
        }
        /* .datatable button {
            text-align: center;
        } */

        .scrollbox {
            height: 400px;
            width: 560px;
            overflow: scroll;
        }

        .active {
            background-color: lightgreen;
        }
        .actionbutton {
            background-color: lightblue;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilat</h1>
        </div>
        <div id="app" class="page-content">
            <readings :readings="readings"></readings>
            <trendgraph :active="false" :elemid="testgraph10" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph4" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph2" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph3" :title="trendtitles"></trendgraph>
            <monthtable :monthlydata="calculated.monthlyaverages"></monthtable>
            <trendgraph :active="false" :elemid="testgraph11" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph5" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph6" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph7" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph8" :title="trendtitles"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph9" :title="trendtitles"></trendgraph>
        </div>
    </div>
    <script type="module">

        import { createApp, ref } from 'vue'

        (async function () {
        })();

        const vueapp = createApp({
            data() {
                return {
                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    testgraph9: 'GraphLocation9',
                    testgraph10: 'GraphLocation10',
                    testgraph11: 'GraphLocation11',
                    trendtitles: [],
                    calculatedDailyAverages: [],
                    defaultyear: 1976,
                    readings: { values: [], filtered: [], filtersize: 10 },
                    monthnames: ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'],
                    monthnamesLong: ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'],
                    calculated : {
                        sums: [],             // YearCalcValue[]
                        monthlytrends: [],    // MonthDataPair[]
                        monthlyaverages: [],  // YearlyAverage[]
                        linearcont: [],       // TemperatureValue[]
                    }
                }
            },
            async mounted() {
                let years = await apiGetYears('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', 'Salo');
                //years.data = [2021,2022,2023,2024]
                let temperatures = await apiGetTemperatures('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', "Salo", years.data);
                this.checkData(temperatures);

                this.calculated.sums = calculateDailyAveragesTS(temperatures, this.defaultyear);
                this.calculated.monthlytrends = calculateMonthlyTrendsTS(temperatures);
                this.calculated.monthlyaverages = calculateMonthlyAveragesTS(temperatures);
                this.calculated.linearcont = createLinearContTableTS(temperatures);
                this.readings.filtered = filterSeriesTS(this.calculated.linearcont, this.readings.filtersize);

                this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', temperatures, this.createAllYearsMonthlyAverageSeriedata);
                this.createChart(this.testgraph10, 'Suodatetut lampotilat', temperatures, this.createAllYearsFilteredSeriedata);
                this.createChart(this.testgraph2, 'Päivittäinen keskiarvo', temperatures, this.createAllYearsAverageSeriedata);
                this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', temperatures, this.createAllYearsSeriedata);
                this.createChart(this.testgraph4, 'Viimeinen vuosi', temperatures, this.createLastYearsSeriedata);
                this.createChart(this.testgraph11, 'Vuosittainen suuntaus', temperatures, this.createYearlyTrendSeriedata);
                this.createChart(this.testgraph5, 'Kesän suuntaus', temperatures, this.createMonthlySummerTrendSeriedata);
                this.createChart(this.testgraph6, 'Talven suuntaus', temperatures, this.createMonthlyWinterTrendSeriedata);
                this.createChart(this.testgraph7, 'Syksyn suuntaus', temperatures, this.createMonthlyFallTrendSeriedata);
                this.createChart(this.testgraph8, 'Kevään suuntaus', temperatures, this.createMonthlySpringTrendSeriedata);
                this.createChart(this.testgraph9, 'Aamun ja illan ero', temperatures, this.createDailyDiffdata);

                formatFilteredTableTS(temperatures.data, this.readings.filtered);
            },
            components: {
                readings: {
                    props: ['readings'],
                    data: function () {
                        return {
                            selected: ref(-1),
                            sum: ref(0),
                        }
                    },
                    computed: {
                        calculateAverage: function () {
                            this.sum = 0;
                        }
                    },
                    methods: {
                        setSum(value) {
                            this.sum = value;
                        },
                        calcSums() {
                            let check = this.$root.isNumeric;
                            let setvalue = this.setSum;
                            setTimeout(function () {
                                let elements = document.getElementsByClassName('xxx active');
                                if (elements.length == 0) {
                                    setvalue(0);
                                    return;
                                }
                                let index;
                                let sum = 0;
                                let count = 0;
                                for (index = 0; index < elements.length; index++) {
                                    if (check(elements[index].innerText)) {
                                        sum += Number(elements[index].innerText);
                                        count++;
                                    }
                                }
                                if (count > 0) setvalue(sum / count);
                                else setvalue(-1);
                            }, 1)
                        },
                        getDateTxt(date) {
                            if (date == null || date === undefined || isNaN(date)) {
                                return '????';
                            }
                            return (date) ? `${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear()}` : `-`;
                        },
                        selectDay(item) {
                            if (this.selected == item.index) this.selected = -1;
                            else this.selected = item.index;
                            this.calcSums();
                        },
                        markIfPressed(item) {
                            if (this.selected < 0) return { active: false };
                            if (this.selected == item.index) return { active: true }
                            return { active: false };
                        },
                        markIfSelected(item) {
                            if (this.selected < 0) return { active: false };

                            if (item.date >= this.readings.filtered[this.selected].firstday &&
                                item.date < this.readings.filtered[this.selected].lastday) {
                                return {
                                    active: true
                                }
                            }
                            return { active: false }
                        },
                        saveValuestoFile() {
                            let data = this.readings.filtered.map(line => (
                                `${this.getDateTxt(line.date)}\t${this.$root.roundNumber(line.morning, 1)}\t${this.$root.roundNumber(line.evening, 1)}\t${this.$root.roundNumber(line.value, 1)}`
                            ));
                            let filename = 'readings.txt';
                            this.saveToFile(`Päivämäärä\tAamu\tIlta\tSuodatettu(${this.readings.filtersize})\n${data.join('\n')}`, filename, `Tallennettu tiedostoon ${filename}`, '');
                        },
                        saveToFile(dataToSave, fileName, successmsg, eventname) {
                            var gameblob = new Blob([dataToSave], { type: 'text/plain' })
                            if (this.objUrl !== null) window.URL.revokeObjectURL(this.objUrl);
                            this.objUrl = (window.webkitURL || window.URL).createObjectURL(gameblob);
                            var anchor = document.createElement('a');
                            anchor.download = fileName;
                            anchor.href = this.objUrl;
                            anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
                            anchor.click();
                            // document.querySelector("body").dispatchEvent(
                            //     new CustomEvent(eventname, {
                            //         bubbles: true,
                            //         detail: { text: () => successmsg },
                            //     })
                            // );
                        },

                    },
                    template: `
                        Mittaustulokset ja suodatettu arvo
                        <div><button class="actionbutton" @click="saveValuestoFile">Tallenna lukemat tiedostoon</button></div>
                        <div class="scrollbox">
                        <table class="datatable">
                            <thead><tr><td></td><td>Aamulämpö</td><td>Iltalämpö</td><td>Suodatettu({{readings.filtersize}})</td><td>Alkupvm</td><td>Loppupvm</td></tr></thead>
                            <tbody>
                                <tr v-for="item in readings.filtered">
                                    <td :class="markIfPressed(item)" align="center"> <button class="actionbutton" @click="selectDay(item)" :class="markIfPressed(item)">{{ this.getDateTxt(item.date) }} </button> </td>
                                    <td class="xxx" :class="markIfSelected(item)"> {{ this.$root.roundNumber(item.morning, 1) }} </td>
                                    <td class="xxx" :class="markIfSelected(item)"> {{ this.$root.roundNumber(item.evening, 1) }} </td>
                                    <td :class="markIfPressed(item)"> {{ this.$root.roundNumber(item.value, 1) }} </td>
                                    <td> {{ getDateTxt(item.firstday) }} </td>
                                    <td> {{ getDateTxt(item.lastday) }} </td>
                                </tr>                                
                            </tbody>
                        </table>            
                        </div>            
                        `
                },
                monthtable: {
                    props: ['monthlydata'],
                    template: `
                        Kuukausittaiset lämpötilat
                        <table class="datatable">
                            <thead>
                                <tr>
                                    <th></th><th v-for="month in this.$root.monthnames">{{ month }}</th>
                                    <th>Koko vuosi</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in monthlydata">
                                    <td>{{ item.year }}</td> 
                                    <td v-for="m in item.months">{{ isNaN(m.average) ? '-' : this.$root.roundNumber(m.average, 1) }}</td>
                                    <td>{{ item.estimate===true ? '(': ''}} {{this.$root.roundNumber(item.yearaverage, 1)}} {{ item.estimate==true?')':''}}</td>
                                </tr>                                
                            </tbody>
                        </table>
                        `
                },
                trendgraph: {
                    props: ['active', 'elemid', 'title'],
                    template: `
                        <div :class="{hidden: !active}" class="trendchart">
                            <div class="trendtitle"></div>
                            <div :id="elemid" class="graphelement"></div>
                        </div>
                        `
                }
            },
            methods: {
                checkData(temperatures) {
                    temperatures.data.forEach(t => {
                        const year = t.info.year;
                        let prevdate = 0;
                        t.data.forEach(d => {
                            if (d.datetimeLocal.getFullYear() !== year) {
                                alert(`Invalid year ${d.date.getFullYear()}`);
                            }
                            if (prevdate >= d.datetimeLocal) {
                                alert(`Invalid date ${d.datetimeLocal.getDate(0)}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`);
                            }
                            prevdate = d.datetimeLocal;
                        })
                    })
                },
                createChart(element, title, temperatures, funct) {
                    let trendChart = this.initSerie(element);
                    if (trendChart === null) return;
                    let serieoptions = this.buildChartOptions(title, funct(temperatures));
                    trendChart.setOption(serieoptions);
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                getMinMaxValue(series) {
                    let min = getTempMinDefaultValue();
                    let max = getTempMaxDefaultValue();
                    series.data.forEach(s => {
                        s.values.forEach(point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return { min: min, max: max }
                },
                getSelection(seriedata, selectedseries) {
                    let selection = {};
                    seriedata.data.forEach(s => {
                        selection[s.name] = false;
                    })
                    if (selectedseries && selectedseries.length) {
                        selectedseries.forEach(s => {
                            selection[s] = true;
                        })
                    }
                    return selection;
                },                
                buildChartOptions(title, series) {
                    const monthnames = this.monthnames;
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function (value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (series.params && series.params.legend && series.params.legend.items) {
                                        return series.params.legend.items[m];
                                    }
                                    if (y < 1978) return monthnames[m];
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series, series.params),
                        legend: {
                            show: false,
                            // data: ['1','2','3']
                            //     data: series.data.map(s => s.year),
                            // //     inactiveColor: '#aaa',
                            textStyle: { color: '#f0f', fontSize: '16' },
                            //     type: 'scroll',
                            //     //orient: 'vertical',
                            //     //top: 0,
                            //     //right: 20,
                        },
                    };
                    if (series.params) {
                        if (series.params.rangeoffset) {
                            let minmax = this.getMinMaxValue(series);
                            let offset = Number(series.params.rangeoffset);
                            chartoptions.yAxis.min = this.roundNumber(minmax.min - offset - 1, 0);
                            chartoptions.yAxis.max = this.roundNumber(minmax.max + offset, 0);
                        }
                        if (series.params.showlegend) {
                            chartoptions.legend.show = true;
                        }
                        if (series.params.selection) {
                            chartoptions.legend.selected = this.getSelection(series, series.params.selection);
                        }
                    }

                    return chartoptions;
                },
                getDate(date) {
                    let parts = date.split('/');
                    if (parts && parts.length === 3) {
                        return new Date(parts[2], Number(parts[0]) - 1, parts[1]);
                    }
                    return NaN;
                },
                getDateTxt(date, daymonth) {
                    if (!date) return '???';
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    if (daymonth === true) return `${day}.${month}`;
                    return `${day}.${month}.${date.getFullYear()}`;
                },
                isNumeric(obj) {
                    return !Array.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
                },
                roundNumber(value, num) {
                    if (this.isNumeric(value)) {
                        if (typeof value === 'number') return value.toFixed(num);
                        else return value;
                    }
                    if (isNaN(value)) return 'NaN';
                    return 'kummaa'
                },createSeries(series, params) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 3,
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                    }))

                    if (params) {
                        if (params.series) {
                            params.series.forEach(p => {
                                if (p.name == '') {
                                    // apply to all series
                                    if (p.markersize !== undefined) {
                                        chartdata.forEach(chart => {
                                            chart.symbolSize = p.markersize;
                                        })
                                    }
                                }
                            })
                            chartdata.forEach(d => {
                                let found = params.series.find(p => p.name === d.name);
                                if (found) {
                                    //d.showSymbol = false;
                                    //d.symbol = 'none';
                                    d.symbolSize = 1;
                                    if (found.color) d.lineStyle = { color: found.color }
                                    // d.markPoint = {symbolSize: 0, opacity: 0};
                                }
                            })
                        }
                    }
                    return chartdata;
                },
                // ---------------------------------------------------------------------------------------------
                createLastYearsSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const lastdate = this.getDate(series.data[series.data.length - 1].data[series.data[series.data.length - 1].data.length - 1].date);
                    const firstdate = new Date(lastdate.getFullYear() - 1, lastdate.getMonth(), lastdate.getDate());
                    const readings = getReadingsBetweenTS(firstdate, lastdate, series);
                    const data = createLastYearsSeriedataTS(readings, this.calculated.sums, series.data[0].info.location);

                    return {
                        data: data,
                        params: { showlegend: true, series: [{ name: 'Minimi', color: '#777777' }, { 'name': 'Maksimi', color: '#777777' }], legend: { items: this.monthnames } }
                    };
                    /*
                    let values = [];
                    values.push({value: [datetime, reading], tooltip: ''})

                    let datavalues = [];
                    datavalues.push({values: values, location: '', year: 2000})

                    return {data: datavalues, params: null}
                    */
                },

                createDailyDiffdata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const curvedata = getDiffCurveDataTS(this.readings.filtered, this.calculated.sums, series.data[series.data.length - 1].info.year, this.defaultyear, series.data[0].info.location);
                    
                    const selection = curvedata.map(c => (c.name))
                    const seriedata = {
                        data: curvedata,
                        params: { showlegend: true, series: [{ name: 'Minimi', color: '#777777' }, { name: 'Maksimi', color: '#777777' }], selection: selection }
                    };
                    return seriedata;
                },
                createAllYearsSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const returnvalues = series.data.map(yearserie => ({
                        values: yearserie.data.map(s => ({
                            value: [this.getDate(s.date), s.morning],
                            tooltip: `${yearserie.info.location} ${this.getDateTxt(this.getDate(s.date))} ${s.morning}`,
                        })),
                        location: yearserie.info.location,
                        year: yearserie.info.year,
                    }))
                    const seriedata = { data: returnvalues, params: { series: [{ name: '', markersize: 1 }] }};
                    return seriedata;
                },


                createYearlyTrendSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const data = getYearlyTrendTS(series, this.calculated.monthlytrends);

                    return { data: data, params: { rangeoffset: 1, showlegend: true} };
                },
                createMonthlySummerTrendSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const datavalues = getSeasonTrendsTS(series, [6, 7, 8], ['Kesäkuu', 'Heinäkuu', 'Elokuu'], this.calculated.monthlytrends);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createMonthlyWinterTrendSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const datavalues = getSeasonTrendsTS(series, [1, 2, 12], ['Tammikuu', 'Helmikuu', 'Joulukuu'], this.calculated.monthlytrends);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createMonthlyFallTrendSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const datavalues = getSeasonTrendsTS(series, [9, 10, 11], ['Syyskuu', 'Lokakuu', 'Marraskuu'], this.calculated.monthlytrends);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createMonthlySpringTrendSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const datavalues = getSeasonTrendsTS(series, [4, 5, 6], ['Huhtikuu', 'Toukokuu', 'Kesäkuu'], this.calculated.monthlytrends);
                    return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                },
                createAllYearsMonthlyAverageSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                    const datavalues = createAllYearsMonthlySeriedataTS(series, this.calculated.monthlyaverages,this.defaultyear);

                    return {data: datavalues, params: null};
                },
                createAllYearsFilteredSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }
                    const valuearray = createAllYearsFilteredSerieTS(series, this.readings.filtered, this.defaultyear);
                    let curyear = series.data[series.data.length-1].data[0].datetimeLocal.getFullYear().toString();
                    const seriedata = {
                        data: valuearray,
                        params: { showlegend: true, selection: [curyear, 'Minimi', 'Maksimi'], series: [{ name: 'Minimi', color: '#777777' }, { 'name': 'Maksimi', color: '#777777' }] }
                    };
                    return seriedata;
                },
                createAllYearsAverageSeriedata(series) {
                    if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }
                    const data = createAllyearsAverageSerieTS(series, this.calculated.sums)
                    const seriedata = { data: data, params: null };
                    return seriedata;
                },


                //initSerieLegends(data) {
                // let selection = [];
                // if (activation.playernumbers && activation.playernumbers.length) {
                //     activation.playernumbers.forEach((pno, i) => {
                //         let foundplayer = data.options.chartitems.find((item, index) => {
                //             let matchplayer = item.name.match(/^(\d{1,2}) ./);
                //             return (matchplayer && pno == Number(matchplayer[1]));
                //         });
                //         if (foundplayer) selection.push(foundplayer.name);
                //     });
                // }
                // else if (activation.names && activation.names.length) {
                //     return activation.names;
                // }
                //return selection;
                //},

            }
        }).mount('#app');

    </script>

</body>

</html>