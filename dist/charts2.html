<!DOCTYPE html>

<html>

<head>
    <title>Lämpötilat</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <script>let exports = {};</script>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>

    <script src="js/echarts5.4.3.js"></script>
    <link href="css/loader.css" rel="stylesheet">
    <script src="api/api.js" defer></script>

    <script src="chartfunctions2.js" defer></script>

    <style>

        .graphelement {
            width: 1100px;
            height: 380px;
        }
        .datatable,
        .datatable th,
        .datatable td {
            border: 1px solid;
            text-align: center;
        }
        .active {
            background-color: lightgreen;
        }
        .actionbutton {
            background-color: lightblue;
        }
        .actionbutton.active {
            background-color: red;
        }
        .setmargin5 {
            margin: 5px;
        }
        #daygraph {
            display: inline-block;
            width: 400px;
            height: 380px;
        }
        .scrollbox {
            height: 400px;
            width: 520px;
            overflow: scroll;
        }
        @media screen and (max-width: 1080px) {
            .scrollbox {
                height: 420px;
                width: 420px;
                overflow: scroll;
            }            
        } 
        @media screen and (max-width: 800px) {
            .hideifnarrow {display:none}
            .scrollbox {
                height: 400px;
                width: 280px;
                overflow: scroll;
            }        
        }        
    
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="page-title">
            <h1 id="ID_PageTitle">Lämpötilat</h1>
        </div>
        <div id="app" class="page-content">
            <div class="row">
                <div class="col-6">
                    <readings :readings="allreadingsfiltered" @newday="dayselected"></readings>
                </div>
                <div class="col-6" :style="daydata.data[0].length>0?'display:inline-block;':'display:none;'">
                    <button type="button" :disabled="this.scrollday.scroll" class="btn btn-primary setmargin5" @click="rundays">Rullaa</button>
                    <button type="button" :disabled="!this.scrollday.scroll" class="btn btn-primary setmargin5" @click="stopdays">Pysäytä</button>
                    <hr>
                    <div id="daygraph"></div>
                </div>
            </div>
            <trendgraph :active="false" :elemid="testgraph10"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph4"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph12"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph2"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph3"></trendgraph>
            <monthtable :monthlydata="calculated.monthlyaverages.values" :monthaverages="calculated.monthlyaverages.averages" :monthnames="monthnames"></monthtable>
            <trendgraph :active="false" :elemid="testgraph11"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph5"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph6"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph7"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph8"></trendgraph>
            <trendgraph :active="false" :elemid="testgraph9"></trendgraph>
        </div>
    </div>
    <script type="module">

        import { createApp, ref } from 'vue'

        function selectFirstDay() {
            let button = document.getElementsByClassName('daybutton_0');
            if (button && button.length) button[0].click();
            else setTimeout(() => { selectFirstDay(); }, 50);
        }
        (async function () {
            setTimeout(() => { selectFirstDay(); }, 50);
        })();

        const vueapp = createApp({
            data() {
                return {
                    allreadingsfiltered: {values: [], filtersize: 0},
                    testgraph: 'GraphLocation',
                    testgraph2: 'GraphLocation2',
                    testgraph3: 'GraphLocation3',
                    testgraph4: 'GraphLocation4',
                    testgraph5: 'GraphLocation5',
                    testgraph6: 'GraphLocation6',
                    testgraph7: 'GraphLocation7',
                    testgraph8: 'GraphLocation8',
                    testgraph9: 'GraphLocation9',
                    testgraph10: 'GraphLocation10',
                    testgraph11: 'GraphLocation11',
                    testgraph12: 'GraphLocation12',
                    defaultyear: 1976,
                    daydata: {data: [[],[]], chart: null},
                    //readings: { values: [], filtered: [], filtersize: 10 },
                    scrollday: {
                        firstdate: null,
                        selecteddate: null,
                        selecteddayindex: -1,
                        scroll: false,
                    },
                    yearlyHiLoReadings: ref([]),
                    monthnames: ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'],
                    monthnamesLong: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
                    calculated : {
                        sums: [],             // YearCalcValue[]
                        monthlytrends: [],    // MonthDataPair[]
                        monthlyaverages: {values: [], calculated: [], averages: []},  // YearlyAverage[]
                        //linearcont: [],       // TemperatureValue[]
                    },
                    charts: [],
                }
            },
            async mounted() {
                let years = await apiGetYears('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', 'Salo');
                //years.data = [2021,2022,2023,2024]
                let temperatures = await apiGetTemperatures('1eb8859e-21d9-49cd-8fa5-b09ff5d32adc', "Salo", years.data);
                this.checkData(temperatures);

                initTemperature(temperatures);
                calculateTemperatures(temperatures);

                this.allreadingsfiltered = getAllReadings();
                this.createChart(this.testgraph10, 'Suodatetut lampotilat', temperatures, createYearlyFilteredSeriedata);
                this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', temperatures, createAllYearsFilteredSeriedata);

                //this.calculated.sums = calculateDailyAveragesTS(temperatures, this.defaultyear);
                //this.calculated.monthlytrends = calculateMonthlyTrendsTS(temperatures);
                //this.calculated.monthlyaverages = calculateMonthlyAveragesTS(temperatures);
                //this.readings.values = createLinearContTableTS(temperatures);
                //this.readings.filtered = filterSeriesTS(this.readings.values, this.readings.filtersize);

            //    this.createChart(this.testgraph, 'Kuukausittainen keskiarvo', temperatures, createAllYearsMonthlyAverageSeriedata);

            //    this.createChart(this.testgraph10, 'Suodatetut lampotilat', temperatures, this.createAllYearsFilteredSeriedata);
            //    this.createChart(this.testgraph2, 'Päivittäinen keskiarvo', temperatures, this.createAllYearsAverageSeriedata);
            //    this.createChart(this.testgraph3, 'Päivittäinen keskilämpötila', temperatures, this.createAllYearsSeriedata);
            //    this.createChart(this.testgraph4, 'Viimeinen vuosi', temperatures, this.createLastYearsSeriedata);

            //    this.createChart(this.testgraph11, 'Vuosittainen suuntaus', temperatures, this.createYearlyTrendSeriedata);

            //    this.charts.push(this.createChart(this.testgraph5, 'Kesän suuntaus', temperatures, this.createMonthlySummerTrendSeriedata));
            //    this.charts[this.charts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);

            //    this.charts.push(this.createChart(this.testgraph6, 'Talven suuntaus', temperatures, this.createMonthlyWinterTrendSeriedata));
            //    this.charts[this.charts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);

            //    this.charts.push(this.createChart(this.testgraph7, 'Syksyn suuntaus', temperatures, this.createMonthlyFallTrendSeriedata));
            //    this.charts[this.charts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);

            //    this.charts.push(this.createChart(this.testgraph8, 'Kevään suuntaus', temperatures, this.createMonthlySpringTrendSeriedata));
            //    this.charts[this.charts.length-1].trendChart.on('legendselectchanged', this.monthlytrendcallback);

            //    this.createChart(this.testgraph9, 'Aamun ja illan ero', temperatures, this.createDailyDiffdata);
            //    this.createChart(this.testgraph12, 'Vuosien korkeimmat ja matalimmat', temperatures, this.createYearlyHighValuedata);

            //     formatFilteredTableTS(temperatures.data, this.readings.filtered);

            },
            updated() {
                // let button = document.getElementsByClassName('daybutton_0');
                // if (button && button.length) button[0].click();
            },
            components: {
                readings: {
                    props: ['readings'],
                    emits: ['newday'],
                    data: function () {
                        return {
                            selected: ref(-1),
                            sum: ref(0),
                        }
                    },
                    computed: {
                        calculateAverage: function () {
                            this.sum = 0;
                        }
                    },
                    methods: {
                        setSum(value) {
                            this.sum = value;
                        },
                        roundNumber(value, num) {
                            return roundNumber(value, num)
                        },
                        calcSums() {
                            let setvalue = this.setSum;
                            setTimeout(function () {
                                let elements = document.getElementsByClassName('xxx active');
                                if (elements.length == 0) {
                                    setvalue(0);
                                    return;
                                }
                                let index;
                                let sum = 0;
                                let count = 0;
                                for (index = 0; index < elements.length; index++) {
                                    if (isNumeric(elements[index].innerText)) {
                                        sum += Number(elements[index].innerText);
                                        count++;
                                    }
                                }
                                if (count > 0) setvalue(sum / count);
                                else setvalue(-1);
                            }, 1)
                        },
                        getDateTxt(date) {
                            if (date == null || date === undefined || isNaN(date)) {
                                return '????';
                            }
                            return (date) ? `${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear()}` : `-`;
                        },
                        selectDay(item) {
                            if (this.selected == item.index) this.selected = -1;
                            else this.selected = item.index;
                            this.calcSums();
                            if (this.selected == item.index) {
                                // 
                                const selectedday = this.readings.values[this.selected].date.getDate();
                                const selectedmonth = this.readings.values[this.selected].date.getMonth();
                                // **************
                                let values = this.readings.values.map(r => {
                                    if (r && r.date && r.date.getDate() == selectedday && r.date.getMonth() == selectedmonth) {
                                        return {date: r.date, value: r.average, morning: r.morning, evening: r.evening, datetimeLocal: r.date}
                                    }
                                    else return null
                                })
                                this.$emit('newday', {values: values.filter(v => v !== null), selected: this.selected});
                            }
                            else this.$emit('newday', {values: [], selected: -1});
                        },
                        markIfPressed(item) {
                            if (this.selected < 0) return { active: false };
                            if (this.selected == item.index) return { active: true }
                            return { active: false };
                        },
                        getClass(index) {
                            return `daybutton_${index}`;
                        },
                        markIfSelected(item) {
                            if (this.selected < 0) return { active: false };

                            if (item.date >= this.readings.values[this.selected].firstdayfilter &&
                                item.date < this.readings.values[this.selected].lastdayfilter) {
                                return { active: true }
                            }
                            return { active: false }
                        },
                        saveValuestoFile() {
                            let data = this.readings.values.map(line => (
                                `${this.getDateTxt(line.date)}\t${roundNumber(line.morning, 1)}\t${roundNumber(line.evening, 1)}\t${roundNumber(line.value, 1)}`
                            ));
                            let filename = 'readings.txt';
                            this.saveToFile(`Päivämäärä\tAamu\tIlta\tSuodatettu(${this.readings.filtersize})\n${data.join('\n')}`, filename, `Tallennettu tiedostoon ${filename}`, '');
                        },
                        saveToFile(dataToSave, fileName, successmsg, eventname) {
                            var gameblob = new Blob([dataToSave], { type: 'text/plain' })
                            if (this.objUrl !== null) window.URL.revokeObjectURL(this.objUrl);
                            this.objUrl = (window.webkitURL || window.URL).createObjectURL(gameblob);
                            var anchor = document.createElement('a');
                            anchor.download = fileName;
                            anchor.href = this.objUrl;
                            anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
                            anchor.click();
                            // document.querySelector("body").dispatchEvent(
                            //     new CustomEvent(eventname, {
                            //         bubbles: true,
                            //         detail: { text: () => successmsg },
                            //     })
                            // );
                        },

                    },
                    template: `
                        Mittaustulokset ja suodatettu arvo
                        <div><button type="button" class="btn btn-primary" @click="saveValuestoFile">Tallenna lukemat tiedostoon</button></div>
                        <div class="scrollbox">
                        <table class="datatable">
                            <thead><tr><td></td><td>Aamu</td><td>Ilta</td><td>Suod({{readings.filtersize}})</td><td class="hideifnarrow">Alkupvm</td><td class="hideifnarrow">Loppupvm</td></tr></thead>
                            <tbody>
                                <tr v-for="(item, index) in readings.values">
                                    <td :class="markIfPressed(item)" align="center"> 
                                        <button class="actionbutton" @click="selectDay(item)" :class="markIfPressed(item),getClass(index)">
                                            {{ getDateTxt(item.date) }} 
                                        </button> 
                                    </td>
                                    <td class="xxx" :class="markIfSelected(item)"> {{ roundNumber(item.morning, 1) }} </td>
                                    <td class="xxx" :class="markIfSelected(item)"> {{ roundNumber(item.evening, 1) }} </td>
                                    <td :class="markIfPressed(item)"> {{ roundNumber(item.averagefiltered, 1) }} </td>
                                    <td class="hideifnarrow"> {{ getDateTxt(item.firstdayfilter) }} </td>
                                    <td class="hideifnarrow"> {{ getDateTxt(item.lastdayfilter) }} </td>
                                </tr>                                
                            </tbody>
                        </table>            
                        </div>            
                        `
                },
                monthtable: {
                    props: ['monthlydata', 'monthnames', 'monthaverages'],
                    emits: ['lastyear'],
                    methods: {
                        roundNumber(value, num) {
                            return roundNumber(value, num);
                        },
                    },
                    template: `
                        Kuukausittaiset lämpötilat
                        <table class="datatable">
                            <thead>
                                <tr>
                                    <th></th><th v-for="month in monthnames">{{ month }}</th>
                                    <th>Koko vuosi</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in monthlydata">
                                    <td>{{ item.year }}</td> 
                                    <td v-for="m in item.months">{{ isNaN(m.average) ? '-' : roundNumber(m.average, 1) }}</td>
                                    <td>{{ item.estimate===true ? '(': ''}} {{roundNumber(item.yearaverage, 1)}} {{ item.estimate==true?')':''}}</td>
                                </tr>                                
                            </tbody>
                            <tfoot>
                                <tr>
                                    <th>Yht</th>
                                    <th v-for="value in monthaverages">{{ roundNumber(value,1) }}</th>
                                </tr>
                            </tfoot>
                        </table>
                        `
                },
                trendgraph: {
                    props: ['active', 'elemid', 'title'],
                    template: `
                        <div :class="{hidden: !active}" class="trendchart">
                            <div class="trendtitle"></div>
                            <div :id="elemid" class="graphelement"></div>
                        </div>
                        `
                }
            },
            methods: {
                monthlytrendcallback(params) {
                    const seriestatus = Object.keys(params.selected).map(k => ({status: params.selected[k], name: k}));
                    let i = 0;
                    let j;
                    let chart = null;
                    while (!chart && i < this.charts.length) {
                        j = 0;
                        while (j < this.charts[i].serieOptions.series.length && !chart) {
                            // only one serie cheked, maybe should be more
                            let search = seriestatus.find(s => this.charts[i].serieOptions.series[j].trend == false && this.charts[i].serieOptions.series[j].name == s.name);
                            if (search) chart = this.charts[i];
                            else j++;
                        }
                        if (!chart) i++;
                    }
                    if (!chart) return;

                    const series = chart.serieOptions.series.map(d => {
                        let search = seriestatus.find(s => s.name == d.name);
                        if (!d.trend && search && search.status === true) {
                            // serie active
                            return {
                                name: d.name,
                                num: d.num,
                                data: d.data.map(val => ({
                                    value: isNumeric(val.value[1]) ? Number(val.value[1]) : NaN,
                                    year:  val.value[0].getFullYear(),
                                }))
                            }
                        }
                        return null;
                    }).filter(v => v !== null);

                    const originaltrendserie = chart.serieOptions.series.find(d => d.trend == true);
                    if (!originaltrendserie) return;
                    const tempserie = {data: chart.serieOptions.series[0].data.map(ss => ({info: {year: ss.value[0].getFullYear(), location: ''}}))};
                    const datavalues = getSeasonTrendsTS(tempserie, series.map(s => s.num), series.map(s => s.name), this.calculated.monthlytrends);
                    const newtrendserie = datavalues.find(d => d.trend == true);
                    if (!newtrendserie) return;
                    originaltrendserie.data = newtrendserie.values.map(v => v);
                    originaltrendserie.name = newtrendserie.name;
                    chart.trendChart.setOption(chart.serieOptions);
                },                
                checkData(temperatures) {
                    temperatures.data.forEach(t => {
                        const year = t.info.year;
                        let prevdate = 0;
                        t.data.forEach(d => {
                            if (d.datetimeLocal.getFullYear() !== year) {
                                alert(`Invalid year ${d.date.getFullYear()}`);
                            }
                            if (prevdate >= d.datetimeLocal) {
                                alert(`Invalid date ${d.datetimeLocal.getDate(0)}.${d.datetimeLocal.getMonth()+1}.${d.datetimeLocal.getFullYear()}`);
                            }
                            prevdate = d.datetimeLocal;
                        })
                    })
                },
                createChart(element, title, data, funct, thischart) {
                    let trendChart = (thischart ? thischart.trendChart : this.initSerie(element));
                    if (trendChart === null) return;
                    const buildValues = funct(data);
                    const params = buildValues.params;
                    let serieOptions = this.buildChartOptions(title, buildValues);

                    trendChart.setOption(serieOptions);
                    return {trendChart, serieOptions, params};
                },
                initSerie(element) {
                    const graphelem = document.getElementById(element);
                    if (graphelem === null) return null;
                    return echarts.init(graphelem);
                },
                getMinMaxValue(series) {
                    let min = getTempMinDefaultValue();
                    let max = getTempMaxDefaultValue();
                    series.data.forEach(s => {
                        s.values.forEach(point => {
                            let val = Number(point.value[1])
                            if (val > max) max = val;
                            if (val < min) min = val;
                        })
                    })
                    return { min: min, max: max }
                },
                getSelection(seriedata, selectedseries) {
                    let selection = {};
                    seriedata.data.forEach(s => {
                        selection[s.name] = false;
                    })
                    if (selectedseries && selectedseries.length) {
                        selectedseries.forEach(s => {
                            selection[s] = true;
                        })
                    }
                    return selection;
                },                
                buildChartOptions(title, series) {
                    const monthnames = this.monthnames;
                    let chartoptions = {
                        animation: false,
                        title: {
                            text: title,
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                return params.data.text;
                            }
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: (function (value) {
                                    let v = new Date(value);
                                    let m = v.getMonth();
                                    let y = v.getFullYear();
                                    let d = v.getDate();
                                    if (series.params && series.params.legend && series.params.legend.items) {
                                        return series.params.legend.items[m];
                                    }
                                    if (y < 1978) return monthnames[m];
                                    return y.toString();
                                })
                            },
                            name: 'Aika',
                        },
                        yAxis: {
                            name: 'Lämpötila/°C'
                        },
                        series: this.createSeries(series, series.params),
                        legend: {
                            show: false,
                            // data: ['1','2','3']
                            //     data: series.data.map(s => s.year),
                            // //     inactiveColor: '#aaa',
                            textStyle: { color: '#f0f', fontSize: '16' },
                            //     type: 'scroll',
                            //     //orient: 'vertical',
                            //     //top: 0,
                            //     //right: 20,
                        },
                    };
                    if (series.params) {
                        if (series.params.rangeoffset) {
                            let minmax = this.getMinMaxValue(series);
                            let offset = Number(series.params.rangeoffset);
                            chartoptions.yAxis.min = roundNumber(minmax.min - offset - 1, 0);
                            chartoptions.yAxis.max = roundNumber(minmax.max + offset, 0);
                        }
                        if (series.params.showlegend) {
                            chartoptions.legend.show = true;
                        }
                        if (series.params.selection) {
                            chartoptions.legend.selected = this.getSelection(series, series.params.selection);
                        }
                    }

                    return chartoptions;
                },
                dayselected(data) {
                    // create trend curve
                    if (data.selected >= 0) {
                        this.scrollday.selecteddate = this.scrollday.firstdate = null;
                        this.scrollday.selecteddayindex = data.selected;
                        this.scrollday.scroll = false;
                    }
                    const values = {
                        data: data.values.map(d => ({
                            value: d.value,
                            year: d.date.getFullYear(),
                            date: d.date,
                        }))
                    }
                    const factors = calculateTrendTS([values]);
                    let trend = data.values.map(d => ({
                        value: d.date.getFullYear() * factors.k + factors.b,
                        date: d.date,
                    }))
                    let series = [data.values, trend];
                    this.daydata.data = series;
                    this.daydata.chart = this.createChart('daygraph', 
                        `Päivän ${values.data.length ? values.data[0].date.getDate() : ''}.${values.data.length ? values.data[0].date.getMonth()+1 : ''} vuosittaisarvot (${factors.k > 0 ? '+' : ''}${roundNumber(factors.k * 10, 1)}°C/10v)`, 
                        series, this.createDayGraph, this.daydata.chart);
                },
                rundays() {
                    this.scrollday.scroll = true;
                    this.scrollday.firstdate = this.scrollday.selecteddate = this.allreadingsfiltered.values[this.scrollday.selecteddayindex].date;
                    setTimeout(this.scrolldayfunction, 1);
                },
                stopdays() {
                    this.scrollday.scroll = false;
                    this.scrollday.selecteddate = this.scrollday.firstdate = null;
                },
                scrolldayfunction() {
                    if (this.scrollday.selecteddate === null) return;

                    let newday = new Date(this.scrollday.selecteddate.getFullYear(), this.scrollday.selecteddate.getMonth(), this.scrollday.selecteddate.getDate() - 1);
                    if (newday <= new Date(this.scrollday.firstdate.getFullYear() - 1, this.scrollday.firstdate.getMonth(), this.scrollday.firstdate.getDate())) {
                        this.scrollday.selecteddate =  this.scrollday.firstdate;
                    }
                    else this.scrollday.selecteddate = newday;

                    const selectedday = this.scrollday.selecteddate.getDate();
                    const selectedmonth = this.scrollday.selecteddate.getMonth();
                    let values = this.allreadingsfiltered.values.map(r => {
                        if (r && r.date && r.date.getDate() == selectedday && r.date.getMonth() == selectedmonth) {
                            return {datetimeLocal: r.date, date: r.date, value: r.average, morning: r.morning, evening: r.evening}
                        }
                        else return null
                    }).filter(v => v !== null);

                    this.dayselected({values: values, selected: -1});
                    setTimeout(this.scrolldayfunction, 200);
                },
                getDate(date) {
                    let parts = date.split('/');
                    if (parts && parts.length === 3) {
                        return new Date(parts[2], Number(parts[0]) - 1, parts[1]);
                    }
                    return NaN;
                },
                getDateTxt(date, daymonth) {
                    if (!date) return '???';
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    if (daymonth === true) return `${day}.${month}`;
                    return `${day}.${month}.${date.getFullYear()}`;
                },
                createSeries(series, params) {
                    let chartdata = series.data.map(values => ({
                        type: 'line',
                        symbolSize: 3,
                        data: values.values.map(s => ({
                            value: [s.value[0], s.value[1]],
                            name: values.location,
                            text: `${s.tooltip}`,
                        })),
                        name: values.name,
                        trend: values.trend,
                        num: values.num,
                    }))

                    if (params) {
                        if (params.series) {
                            params.series.forEach(p => {
                                if (p.name == '') {
                                    // apply to all series
                                    if (p.markersize !== undefined) {
                                        chartdata.forEach(chart => {
                                            chart.symbolSize = p.markersize;
                                        })
                                    }
                                }
                            })
                            chartdata.forEach(d => {
                                let found = params.series.find(p => p.name === d.name);
                                if (found) {
                                    d.symbolsize = 1;
                                    if (found.color) d.lineStyle = { color: found.color }

                                    // ?????????? 
                                    if (found.symbolindex == 'last') {
                                        if (d.data.length) {
                                            d.data[d.data.length-1].symbol = found.symbol;
                                            d.data[d.data.length-1].symbolSize = found.symbolsize;
                                        }
                                    }
                                    else {
                                        if (found.symbol) d.symbol = found.symbol;
                                        if (found.symbolsize) d.symbolSize = found.symbolsize;
                                    }
                                    // d.markPoint = {symbolSize: 0, opacity: 0};
                                }
                            })
                        }
                    }
                    return chartdata;
                },
                createDayGraph() {
                    let datavalues = [];
                    this.daydata.data.forEach((serie, i) => {
                        let values = serie.map(dd => (
                            {value: [dd.date, dd.value], tooltip: `Päivä: ${this.getDateTxt(dd.date, false)} ${roundNumber(dd.value, 1)}`}
                        ))
                        datavalues.push({values: values, location: '', year: 0});
                    });
                    return {data: datavalues, params: null}
                },
                // ---------------------------------------------------------------------------------------------
                // createLastYearsSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const lastdate = this.getDate(series.data[series.data.length - 1].data[series.data[series.data.length - 1].data.length - 1].date);
                //     const firstdate = new Date(lastdate.getFullYear() - 1, lastdate.getMonth(), lastdate.getDate());
                //     const readings = getReadingsBetweenTS(firstdate, lastdate, series);
                //     const data = createLastYearsSeriedataTS(readings, this.calculated.sums, series.data[0].info.location);

                //     return {
                //         data: data,
                //         params: { showlegend: true, series: [{ name: 'Minimi', color: '#777777' }, { 'name': 'Maksimi', color: '#777777' }], legend: { items: this.monthnames } }
                //     };
                //     /*
                //     let values = [];
                //     values.push({value: [datetime, reading], tooltip: ''})

                //     let datavalues = [];
                //     datavalues.push({values: values, location: '', year: 2000})

                //     return {data: datavalues, params: null}
                //     */
                // },

                // createDailyDiffdata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const curvedata = getDiffCurveDataTS(this.readings.filtered, this.calculated.sums, series.data[series.data.length - 1].info.year, this.defaultyear, series.data[0].info.location);
                    
                //     const selection = curvedata.map(c => (c.name))
                //     const seriedata = {
                //         data: curvedata,
                //         params: { showlegend: true, series: [{ name: 'Minimi', color: '#777777' }, { name: 'Maksimi', color: '#777777' }], selection: selection }
                //     };
                //     return seriedata;
                // },
                // // createAllYearsSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const returnvalues = series.data.map(yearserie => ({
                //         values: yearserie.data.map(s => ({
                //             value: [this.getDate(s.date), s.morning],
                //             tooltip: `${yearserie.info.location} ${this.getDateTxt(this.getDate(s.date))} ${s.morning}`,
                //         })),
                //         location: yearserie.info.location,
                //         year: yearserie.info.year,
                //     }))
                //     const seriedata = { data: returnvalues, params: { series: [{ name: '', markersize: 1 }] }};
                //     return seriedata;
                // },
                // createYearlyTrendSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const lastyearestimate = this.calculated.monthlyaverages.values[this.calculated.monthlyaverages.values.length-1].estimate ? this.calculated.monthlyaverages.values[this.calculated.monthlyaverages.values.length-1].yearaverage : NaN;
                //     const data = getYearlyTrendTS(series, this.calculated.monthlytrends, lastyearestimate);
                //     let params = { rangeoffset: 1, showlegend: true};
                //     if (!isNaN(lastyearestimate)) {
                //         params.series = [{ name: data[0].name, symbol: 'arrow', symbolsize: 14, symbolindex: 'last' }];
                //     }
                //     return { data: data, params: params };
                // },
                // createTrendsDataForGivenMonths(series, monthnumbers, monthnames) {
                //     return {data: getSeasonTrendsTS(series, monthnumbers, monthnames, this.calculated.monthlytrends), params: { rangeoffset: 1, showlegend: true } };
                // },
                // createMonthlySummerTrendSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }
                //     const data = this.createTrendsDataForGivenMonths(series, [6, 7, 8], ['Kesäkuu', 'Heinäkuu', 'Elokuu']);
                //     return data;
                // },
                // createMonthlyWinterTrendSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const datavalues = getSeasonTrendsTS(series, [1, 2, 12], ['Tammikuu', 'Helmikuu', 'Joulukuu'], this.calculated.monthlytrends);
                //     return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                // },
                // createMonthlyFallTrendSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const datavalues = getSeasonTrendsTS(series, [9, 10, 11], ['Syyskuu', 'Lokakuu', 'Marraskuu'], this.calculated.monthlytrends);
                //     return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                // },
                // createMonthlySpringTrendSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const datavalues = getSeasonTrendsTS(series, [3, 4, 5], ['Maaliskuu', 'Huhtikuu', 'Toukokuu'], this.calculated.monthlytrends);
                //     return { data: datavalues, params: { rangeoffset: 1, showlegend: true } };
                // },
                // createAllYearsMonthlyAverageSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }

                //     const datavalues = createAllYearsMonthlySeriedataTS(series, this.calculated.monthlyaverages.values, this.defaultyear, this.monthnamesLong);

                //     return {data: datavalues, params: {showlegend: true}};
                // },
                // createAllYearsFilteredSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }
                //     const valuearray = createAllYearsFilteredSerieTS(series, this.readings.filtered, this.defaultyear);
                //     let curyear = series.data[series.data.length-1].data[0].datetimeLocal.getFullYear().toString();
                //     const seriedata = {
                //         data: valuearray,
                //         params: { showlegend: true, selection: [curyear, 'Minimi', 'Maksimi'], series: [{ name: 'Minimi', color: '#777777' }, { 'name': 'Maksimi', color: '#777777' }] }
                //     };
                //     return seriedata;
                // },
                createYearlyHighValuedata(series) {
                    if (this.yearlyHiLoReadings.length === 0) {
                        this.createAllYearsAverageSeriedata(series);
                    }
                    let hivalues = this.yearlyHiLoReadings.map(v =>({
                        value: [new Date(v.year, 0, 1), v.hicount],
                        tooltip: `Korkein ${v.year} ${v.hicount} kpl`,
                    }))
                    let lovalues = this.yearlyHiLoReadings.map(v =>({
                        value: [new Date(v.year, 0, 1), v.locount],
                        tooltip: `Matalin ${v.year} ${v.locount} kpl`,
                    }))
                    let datavalues = [];
                    datavalues.push({values: hivalues, location: '', year: 0, name:'Korkein'})
                    datavalues.push({values: lovalues, location: '', year: 0, name: 'Matalin'})

                    const seriedata = { data: datavalues, params: { showlegend: true} };
                    return seriedata;  
                },
                // createAllYearsAverageSeriedata(series) {
                //     if (!series || !series.data || series.data.length == 0) { return { data: [], params: null } }
                //     const data = createAllyearsAverageSerieTS(series, this.calculated.sums);
                //     let hiindex = 0;
                //     let loindex = 0;
                //     this.yearlyHiLoReadings = series.data.map(year => ({hicount:0, locount: 0, year:year.info.year}));

                //     while (hiindex < data.length && data[hiindex].name != 'Korkein') hiindex++;
                //     if (hiindex < data.length) {
                //         data[hiindex].values.forEach(val => {
                //             let date = val.tooltip.match(/(\d{1,2}).(\d{1,2}).(\d{4}) /);
                //             if (date && date.length == 4) {
                //                 const year = Number(date[3]);
                //                 let found = this.yearlyHiLoReadings.find(h => h.year==year);
                //                 found.hicount++;
                //             }
                //         })
                //     }
                //     while (loindex < data.length && data[loindex].name != 'Matalin') loindex++;
                //     if (loindex < data.length) {
                //         data[loindex].values.forEach(val => {
                //             let date = val.tooltip.match(/(\d{1,2}).(\d{1,2}).(\d{4}) /);
                //             if (date && date.length == 4) {
                //                 const year = Number(date[3]);
                //                 let found = this.yearlyHiLoReadings.find(h => h.year==year);
                //                 found.locount++;
                //             }
                //         })
                //     }
                //     const seriedata = { data: data, params: null };
                //     return seriedata;
                // },


                //initSerieLegends(data) {
                // let selection = [];
                // if (activation.playernumbers && activation.playernumbers.length) {
                //     activation.playernumbers.forEach((pno, i) => {
                //         let foundplayer = data.options.chartitems.find((item, index) => {
                //             let matchplayer = item.name.match(/^(\d{1,2}) ./);
                //             return (matchplayer && pno == Number(matchplayer[1]));
                //         });
                //         if (foundplayer) selection.push(foundplayer.name);
                //     });
                // }
                // else if (activation.names && activation.names.length) {
                //     return activation.names;
                // }
                //return selection;
                //},

            }
        }).mount('#app');

    </script>

</body>

</html>